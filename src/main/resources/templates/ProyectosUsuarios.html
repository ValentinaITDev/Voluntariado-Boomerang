<!DOCTYPE html>
<html lang="es" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mis Proyectos - Voluntario</title>
    <link rel="stylesheet" th:href="@{/Styles.css}">
    <link rel="stylesheet" href="/ProyectoUsuario.css">
    

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <nav class="navbar">
        <div class="logo">
            <img th:src="@{/images/logo.png}" alt="Boomerang Voluntariado" class="logo-img">
        </div>
        <ul class="nav-links">
            <li><a th:href="@{/dashboard}"><i class="fas fa-tachometer-alt"></i>Dashboard</a></li>
            <li><a th:href="@{/usuario/proyectos}" class="active"><i class="fas fa-project-diagram"></i>Mis Proyectos</a></li>
            <li><a th:href="@{/foros}"><i class="fas fa-comments"></i>Foros</a></li>
            <li><a th:href="@{/usuario/perfil}"><i class="fas fa-user-circle"></i>Perfil</a></li>
            <li><a th:href="@{/logout}"><i class="fas fa-sign-out-alt"></i>Cerrar Sesión</a></li>
        </ul>
    </nav>
    <button class="menu-toggle" id="menuToggle">
        <i class="fas fa-bars"></i>
    </button>
    <div class="projects-user-container">
        <header class="projects-header">
            <h1><i class="fas fa-project-diagram"></i> Proyectos Disponibles</h1>

            <!-- Barra de Pestañas Insertada -->
            <div class="tabs-container">
                <button class="tab-btn active" data-tab="projects">
                    <i class="fas fa-project-diagram"></i> Proyectos
                </button>
                <button class="tab-btn" data-tab="challenges">
                    <i class="fas fa-trophy"></i> Desafíos
                </button>
            </div>
            <!-- Fin Barra de Pestañas -->

            <!-- Barra de Búsqueda -->
             <div class="search-container user-search">
                <input type="text" id="userSearchInput" placeholder="Buscar proyectos..." required>
                <button class="search-btn" onclick="searchItems()">
                    <i class="fas fa-search"></i>
                </button>
            </div>
            <!-- Fin Barra de Búsqueda -->

            <div class="filter-section" id="projects-filters">
                <button class="filter-btn active" data-filter="all">
                    <i class="fas fa-border-all"></i> Todos
                </button>
                <button class="filter-btn" data-filter="participating">
                    <i class="fas fa-user-check"></i> Participando
                </button>
                <button class="filter-btn" data-filter="available">
                    <i class="fas fa-star"></i> Disponibles
                </button>
                <button class="filter-btn" data-filter="expired">
                    <i class="fas fa-calendar-times"></i> Expirados
                </button>
            </div>

            <!-- Filtros para Desafíos -->
            <div class="filter-section" id="challenges-filters" style="display: none;">
                <button class="filter-btn active" data-filter="all">
                    <i class="fas fa-border-all"></i> Todos
                </button>
                <button class="filter-btn" data-filter="active">
                    <i class="fas fa-hourglass-half"></i> En Progreso
                </button>
                <button class="filter-btn" data-filter="completed">
                    <i class="fas fa-check-circle"></i> Completados
                </button>
                <button class="filter-btn" data-filter="available">
                    <i class="fas fa-trophy"></i> Disponibles
                </button>
            </div>
        </header>

        <!-- Contenedor de Proyectos -->
        <div class="projects-grid" id="projects-container">
            <!-- Las tarjetas de proyectos se cargarán dinámicamente aquí -->
        </div>

        <!-- Agregar esto justo después del div projects-grid -->
        <div class="pagination-container" id="projects-pagination">
            <div class="pagination-info">
                <span id="pagination-status">Mostrando página <span id="current-page">1</span> de <span id="total-pages">1</span></span>
                <span id="pagination-total">Total: <span id="total-items">0</span> proyectos</span>
            </div>
            <div class="pagination-controls">
                <button id="prev-page" class="pagination-btn" disabled><i class="fas fa-chevron-left"></i> Anterior</button>
                <div class="page-numbers" id="page-numbers"></div>
                <button id="next-page" class="pagination-btn" disabled>Siguiente <i class="fas fa-chevron-right"></i></button>
            </div>
        </div>

        <!-- Contenedor de Desafíos (nuevo) -->
        <div class="challenges-grid" id="challenges-container" style="display: none;">
            <!-- Las tarjetas de desafíos se cargarán dinámicamente aquí -->
        </div>

        <!-- Agregar esto justo después del div challenges-grid -->
        <div class="pagination-container" id="challenges-pagination" style="display: none;">
            <div class="pagination-info">
                <span id="challenges-pagination-status">Mostrando página <span id="challenges-current-page">1</span> de <span id="challenges-total-pages">1</span></span>
                <span id="challenges-pagination-total">Total: <span id="challenges-total-items">0</span> desafíos</span>
            </div>
            <div class="pagination-controls">
                <button id="challenges-prev-page" class="pagination-btn" disabled><i class="fas fa-chevron-left"></i> Anterior</button>
                <div class="page-numbers" id="challenges-page-numbers"></div>
                <button id="challenges-next-page" class="pagination-btn" disabled>Siguiente <i class="fas fa-chevron-right"></i></button>
            </div>
        </div>
    </div>

    <!-- Estilos específicos para los estados de proyectos -->

    <!-- Plantilla para tarjeta de desafío (oculta) -->
    <template id="challenge-card-template">
        <div class="challenge-card">
            <div class="challenge-banner">
                <div class="challenge-status"></div>
                <svg viewBox="0 0 200 100">
                    <path d="M0,50 C50,50 150,50 200,50" fill="none" stroke="currentColor" stroke-width="2"/>
                </svg>
            </div>
            <div class="challenge-content">
                <h3 class="challenge-title"></h3>
                <p class="challenge-description"></p>
                <div class="challenge-details">
                    <span class="challenge-project"><i class="fas fa-project-diagram"></i></span>
                    <span class="challenge-date"><i class="fas fa-calendar"></i></span>
                    <span class="challenge-reward"><i class="fas fa-gem"></i></span>
                </div>
                <div class="challenge-progress-container">
                    <div class="progress-bar">
                        <div class="progress"></div>
                    </div>
                    <span class="progress-text">0%</span>
                </div>
                <div class="challenge-action"></div>
            </div>
        </div>
    </template>

    <script>
        // Imagen por defecto en Base64 (un rectángulo gris con el icono de imagen)
        const defaultImageBase64 = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgZmlsbD0iI2VlZWVlZSIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iNTAiIHI9IjE1IiBmaWxsPSIjYmJiIi8+PHBvbHlnb24gcG9pbnRzPSIwLDIwMCAyMDAsMTUwIDIwMCwyMDAiIGZpbGw9IiNiYmIiLz48cGF0aCBkPSJNNjAgOTBMOTAgMTUwIDE0MCAxMTAgMTgwIDE3MCIgc3Ryb2tlPSIjYmJiIiBzdHJva2Utd2lkdGg9IjEwIiBmaWxsPSJub25lIi8+PHRleHQgeD0iNDAiIHk9IjEwMCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjE2IiBmaWxsPSIjODg4Ij5TaW4gaW1hZ2VuPC90ZXh0Pjwvc3ZnPg==';
        
        // --- CONFIGURACIÓN API ---
            const API_PROYECTOS_URL = '/api/proyectos';
    const API_DESAFIOS_URL = '/api/desafios';
    const API_USUARIO_URL = '/api/usuarios/me'; // Endpoint hipotético para datos del usuario
    let currentUserProjects = []; // Array para almacenar los IDs de proyectos del usuario actual
    let activeTab = 'projects'; // Pestaña activa por defecto
    let currentPage = 1;
    let totalPages = 1;
    let pageSize = 10; // Valor inicial, se adaptará según respuesta del servidor
    let totalItems = 0;
    
    // Para desafíos
    let challengesCurrentPage = 1;
    let challengesTotalPages = 1;
    let challengesPageSize = 10; // Valor inicial, se adaptará según respuesta del servidor
    let challengesTotalItems = 0;

        const projectsGrid = document.querySelector('.projects-grid');
        const challengesGrid = document.querySelector('.challenges-grid');
        const projectsFilters = document.getElementById('projects-filters');
        const challengesFilters = document.getElementById('challenges-filters');
        const filterButtons = document.querySelectorAll('.filter-btn');
        const tabButtons = document.querySelectorAll('.tab-btn');
        const challengeTemplate = document.getElementById('challenge-card-template');
        
        // Elementos de paginación para proyectos
        const paginationContainer = document.getElementById('projects-pagination');
        const currentPageElement = document.getElementById('current-page');
        const totalPagesElement = document.getElementById('total-pages');
        const totalItemsElement = document.getElementById('total-items');
        const prevPageButton = document.getElementById('prev-page');
        const nextPageButton = document.getElementById('next-page');
        const pageNumbersContainer = document.getElementById('page-numbers');
        
        // Elementos de paginación para desafíos
        const challengesPaginationContainer = document.getElementById('challenges-pagination');
        const challengesCurrentPageElement = document.getElementById('challenges-current-page');
        const challengesTotalPagesElement = document.getElementById('challenges-total-pages');
        const challengesTotalItemsElement = document.getElementById('challenges-total-items');
        const challengesPrevPageButton = document.getElementById('challenges-prev-page');
        const challengesNextPageButton = document.getElementById('challenges-next-page');
        const challengesPageNumbersContainer = document.getElementById('challenges-page-numbers');

        // --- MANEJO DE PESTAÑAS ---
        function switchTab(tab) {
            activeTab = tab;
            
            // Actualizar botones de pestañas
            tabButtons.forEach(btn => {
                if (btn.dataset.tab === tab) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Mostrar/ocultar contenedores
            if (tab === 'projects') {
                projectsGrid.style.display = 'grid';
                challengesGrid.style.display = 'none';
                projectsFilters.style.display = 'flex';
                challengesFilters.style.display = 'none';
                paginationContainer.style.display = 'flex';
                challengesPaginationContainer.style.display = 'none';
                document.getElementById('userSearchInput').placeholder = 'Buscar proyectos...';
            } else {
                projectsGrid.style.display = 'none';
                challengesGrid.style.display = 'grid';
                projectsFilters.style.display = 'none';
                challengesFilters.style.display = 'flex';
                paginationContainer.style.display = 'none';
                challengesPaginationContainer.style.display = 'flex';
                document.getElementById('userSearchInput').placeholder = 'Buscar desafíos...';
                
                // Cargar desafíos si es la primera vez
                if (challengesGrid.childElementCount === 0) {
                    loadChallengesPaginated(1);
                }
            }
        }

        // --- RENDERIZACIÓN DE TARJETAS DE PROYECTO ---
        function renderProjectCard(project, isParticipating) {
            const card = document.createElement('div');
            card.classList.add('project-user-card');
            card.dataset.projectId = project.id;
            
            // Determinar categoría del proyecto
            let category = isParticipating ? 'participating' : 'available';
            
            // Si el proyecto está expirado, sobrescribir la categoría
            if (project.estado === 'EXPIRADO' || project.estado === 'COMPLETO' && !isParticipating) {
                category = 'expired';
            }
            
            card.dataset.category = category;
            card.classList.add(category);
            
            // Convertir estado a texto amigable
            let statusText = 'Disponible';
            if (isParticipating) statusText = 'Participando';
            if (project.estado === 'EXPIRADO') statusText = "Finalizado";
            else if (project.estado === 'COMPLETO' && !isParticipating) statusText = "Completo";
            else if (project.estado === 'CANCELADO') statusText = "Cancelado";
            else if (project.estado === 'COMPLETADO') statusText = "Completado";
            
            // Calcular días restantes
            let daysRemaining = 'N/A';
            if (project.fechaExpiracion) {
                const expDate = new Date(project.fechaExpiracion);
                const now = new Date();
                const diffTime = expDate - now;
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); 
                daysRemaining = diffTime > 0 ? `${diffDays} días restantes` : 'Expirado';
            } else {
                daysRemaining = 'Sin fecha límite';
            }
            
            // Formatear información de participantes
            const participantesInfo = project.participantesActuales !== null ? 
                `${project.participantesActuales}${project.limiteParticipantes ? ' / ' + project.limiteParticipantes : ''}` : 
                'N/A';
            
            // Ruta de imagen con fallback
            const imagePath = project.imagenUrl ? `/static/Proyectos/${project.imagenUrl}` : defaultImageBase64;
            
            // LÓGICA DE BOTONES ACTUALIZADA (igual que en renderProjectCardContent)
            let buttonHtml = '';
            if (isParticipating) {
                // Si participa, siempre puede abandonar (sin importar el estado del proyecto)
                buttonHtml = `<button class="leave-project-btn" data-project-id="${project.id}"><i class="fas fa-sign-out-alt"></i> Abandonar Proyecto</button>`;
            } else if (project.estado === 'ACTIVO') {
                // No participa y el proyecto está activo
                if (project.haAlcanzadoLimiteParticipantes || project.estado === 'COMPLETO') {
                    // Proyecto lleno
                    buttonHtml = `<div class="project-status-message">
                        <i class="fas fa-users"></i> Completo
                    </div>`;
                } else {
                    // Proyecto con cupos disponibles
                    buttonHtml = `<button class="join-project-btn" data-project-id="${project.id}"><i class="fas fa-hand-holding-heart"></i> Participar</button>`;
                }
            } else if (project.estado === 'COMPLETO') {
                // No participa y proyecto completo
                buttonHtml = `<div class="project-status-message">
                    <i class="fas fa-users"></i> Completo
                </div>`;
            } else if (project.estado === 'EXPIRADO') {
                // Proyecto expirado
                buttonHtml = `<div class="project-status-message">
                    <i class="fas fa-clock"></i> Proyecto finalizado
                </div>`;
            } else {
                // Para otros estados (CANCELADO, etc.)
                buttonHtml = `<div class="project-status-message">
                    <i class="fas fa-info-circle"></i> Proyecto ${statusText.toLowerCase()}
                </div>`;
            }
            
            card.innerHTML = `
                <div class="project-banner">
                    <div class="project-status ${project.estado.toLowerCase()}">${statusText}</div>
                    <img class="project-image" src="${imagePath}" alt="${project.nombre}" onerror="this.src='${defaultImageBase64}'">
                    <svg viewBox="0 0 200 100">
                        <path d="M0,50 C50,${isParticipating ? 100 : 0} 150,${isParticipating ? 0 : 100} 200,50" fill="none" stroke="currentColor" stroke-width="2"/>
                    </svg>
                </div>
                <div class="project-content">
                     <h3>${project.nombre}</h3>
                    <p>${project.descripcion || 'Sin descripción.'}</p>
                    <div class="project-details">
                        <span><i class="fas fa-users"></i> ${participantesInfo} voluntarios</span>
                        <span><i class="fas fa-calendar"></i> ${daysRemaining}</span>
                        <span><i class="fas fa-info-circle"></i> Estado: ${project.estado || 'ACTIVO'}</span>
                    </div>
                     <div class="participation-progress">
                         <!-- Progreso no implementado -->
                     </div>
                    ${buttonHtml}
                </div>
            `;
            projectsGrid.appendChild(card);
            
            // Agregar event listeners a los botones
            const joinButton = card.querySelector('.join-project-btn');
            if (joinButton) {
                joinButton.addEventListener('click', function() {
                    joinProject(project.id);
                });
            }
            
            const leaveButton = card.querySelector('.leave-project-btn');
            if (leaveButton) {
                leaveButton.addEventListener('click', function() {
                    leaveProject(project.id);
                });
            }
        }

        // --- RENDERIZACIÓN DE TARJETAS DE DESAFÍO ---
        function renderChallengeCard(challenge) {
            // Clonar la plantilla
            const template = challengeTemplate.content.cloneNode(true);
            const card = template.querySelector('.challenge-card');
            
            // Determinar el estado del desafío
            let status = 'available';
            let statusText = 'Disponible';
            let buttonHtml = '';
            let progressPercent = 0;
            
            if (challenge.participacion) {
                if (challenge.participacion.completado) {
                    status = 'completed';
                    statusText = 'Completado';
                    progressPercent = 100;
                    buttonHtml = `
                        <button class="view-btn" data-challenge-id="${challenge.id}">
                            <i class="fas fa-check-circle"></i> Ver Detalles
                        </button>
                    `;
                } else {
                    status = 'active';
                    statusText = 'En Progreso';
                    progressPercent = challenge.participacion.progreso || 0;
                    buttonHtml = `
                        <button class="complete-btn" data-challenge-id="${challenge.id}">
                            <i class="fas fa-trophy"></i> Completar Desafío
                        </button>
                    `;
                }
            } else {
                buttonHtml = `
                    <button class="participate-btn" data-challenge-id="${challenge.id}">
                        <i class="fas fa-play-circle"></i> Participar
                    </button>
                `;
            }
            
            // Aplicar clase según estado
            card.classList.add(status);
            
            // Configurar datos en la tarjeta
            card.dataset.challengeId = challenge.id;
            card.dataset.category = status;
            
            // Llenar contenido
            card.querySelector('.challenge-status').textContent = statusText;
            card.querySelector('.challenge-title').textContent = challenge.nombre;
            card.querySelector('.challenge-description').textContent = challenge.descripcion || 'Sin descripción';
            
            // Detalles
            card.querySelector('.challenge-project').innerHTML = `<i class="fas fa-project-diagram"></i> Proyecto: ${challenge.proyectoNombre || 'General'}`;
            
            // Fechas
            let fechaInfo = 'Sin fecha límite';
            if (challenge.fechaFin) {
                const fechaFin = new Date(challenge.fechaFin);
                const now = new Date();
                if (fechaFin > now) {
                    const diffTime = fechaFin - now;
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                    fechaInfo = `${diffDays} días restantes`;
                } else {
                    fechaInfo = 'Expirado';
                }
            }
            card.querySelector('.challenge-date').innerHTML = `<i class="fas fa-calendar"></i> ${fechaInfo}`;
            
            // Puntos
            card.querySelector('.challenge-reward').innerHTML = `<i class="fas fa-gem"></i> ${challenge.puntosRecompensa || 0} puntos`;
            
            // Progreso
            card.querySelector('.progress').style.width = `${progressPercent}%`;
            card.querySelector('.progress-text').textContent = `${progressPercent}%`;
            
            // Botón de acción
            card.querySelector('.challenge-action').innerHTML = buttonHtml;
            
            // Agregar la tarjeta al contenedor
            challengesGrid.appendChild(card);
            
            // Aplicar animación de entrada
            setTimeout(() => {
                card.classList.add('show');
            }, 50);
        }

        // --- CARGA DE DATOS DE PROYECTOS PAGINADOS ---
        async function loadDataAndRender(page = 1) {
            projectsGrid.innerHTML = '<p>Cargando proyectos...</p>';
            try {
                // 1. Obtener datos del usuario actual (para saber en cuáles participa)
                const userResponse = await fetch(API_USUARIO_URL);
                if (!userResponse.ok) {
                    if (userResponse.status === 401 || userResponse.status === 403) {
                        throw new Error('No autorizado. Inicia sesión.');
                    } else {
                        throw new Error(`Error ${userResponse.status} obteniendo datos de usuario`);
                    }
                }
                const userData = await userResponse.json();
                console.log('Datos completos del usuario:', userData);
                
                // Guardar datos del usuario en variable global para uso posterior
                window.userData = userData;
                
                // Asegurarse que tengamos la información correcta de los proyectos en los que participa
                currentUserProjects = [];
                
                // Usar proyectosParticipadosIds si existe
                if (userData.proyectosParticipadosIds && Array.isArray(userData.proyectosParticipadosIds)) {
                    currentUserProjects = userData.proyectosParticipadosIds;
                }
                // Compatibilidad con versiones anteriores que usaban proyectosParticipados
                else if (userData.proyectosParticipados && Array.isArray(userData.proyectosParticipados)) {
                    if (userData.proyectosParticipados.length > 0 && typeof userData.proyectosParticipados[0] === 'object') {
                        currentUserProjects = userData.proyectosParticipados.map(p => p.proyectoId || p.id || '');
                    } else {
                        currentUserProjects = userData.proyectosParticipados;
                    }
                }
                
                     // 2. Obtener proyectos paginados - Usar el tamaño de página que venga del backend
                 const projectsResponse = await fetch(`${API_PROYECTOS_URL}?page=${page - 1}`);
                 if (!projectsResponse.ok) {
                      throw new Error(`Error ${projectsResponse.status} obteniendo proyectos`);
                 }
                 
                 // Intentar obtener información de paginación desde headers
                 let headerTotalItems = projectsResponse.headers.get('X-Total-Count');
                 let headerTotalPages = projectsResponse.headers.get('X-Total-Pages');
                 let headerCurrentPage = projectsResponse.headers.get('X-Current-Page');
                 
                 const responseData = await projectsResponse.json();
                 
                 // Determinar si la respuesta es un objeto paginado o array directo
                 let projects;
                 
                 if (responseData && Array.isArray(responseData)) {
                     // Es un array directo
                     projects = responseData;
                     // Si no hay headers, asumir que es una sola página con todos los elementos
                     if (!headerTotalItems) {
                         totalItems = projects.length;
                         totalPages = 1;
                         currentPage = 1;
                         pageSize = projects.length;
                     }
                 } else if (responseData && typeof responseData === 'object') {
                     // Es un objeto paginado
                     if (Array.isArray(responseData.content)) {
                         projects = responseData.content;
                         
                         // Extraer metadatos de paginación del objeto directamente
                         if (responseData.totalElements !== undefined) totalItems = responseData.totalElements;
                         if (responseData.totalPages !== undefined) totalPages = responseData.totalPages;
                         if (responseData.number !== undefined) currentPage = responseData.number + 1;
                         if (responseData.size !== undefined) pageSize = responseData.size;
                         if (responseData.numberOfElements !== undefined && projects.length > 0) {
                             // Si API devuelve el número de elementos en la página actual
                             pageSize = Math.max(pageSize, responseData.numberOfElements);
                         }
                     } else {
                         // Intentar otros formatos comunes de paginación
                         if (responseData.items && Array.isArray(responseData.items)) {
                             projects = responseData.items;
                             if (responseData.total !== undefined) totalItems = responseData.total;
                             if (responseData.pages !== undefined) totalPages = responseData.pages;
                             if (responseData.page !== undefined) currentPage = responseData.page;
                         } else {
                             // Si no se reconoce el formato, intentar usar el objeto completo
                             console.warn('Formato de respuesta no reconocido:', responseData);
                             projects = Array.isArray(responseData) ? responseData : [];
                         }
                     }
                 } else {
                     console.warn('Formato de respuesta inesperado:', responseData);
                     projects = [];
                 }
                 
                 // Si tenemos headers, usar esos valores (tienen prioridad)
                 if (headerTotalItems) totalItems = parseInt(headerTotalItems);
                 if (headerTotalPages) totalPages = parseInt(headerTotalPages);
                 if (headerCurrentPage) currentPage = parseInt(headerCurrentPage) + 1;
                 
                 // Asegurar valores mínimos válidos para evitar errores
                 totalItems = totalItems || projects.length;
                 totalPages = totalPages || 1;
                 currentPage = currentPage || 1;
                 
                 // Actualizar información de paginación en la UI
                 updatePaginationControls();
                
                // Guardar en localStorage la lista actualizada
                saveUserProjectsToLocalStorage();
                
                                 // 3. Renderizar
                 renderAllProjects(projects);

            } catch (error) {
                console.error('Error al cargar datos:', error);
                projectsGrid.innerHTML = `<p>Error al cargar proyectos: ${error.message}. Asegúrate de que el endpoint ${API_USUARIO_URL} exista y funcione.</p>`;
            }
        }
        
        // --- CARGA DE DATOS DE DESAFÍOS PAGINADOS --- 
        async function loadChallengesPaginated(page = 1) {
            challengesGrid.innerHTML = '<p>Cargando desafíos...</p>';
            try {
                // 1. Obtener mis participaciones en desafíos
                const participacionesResponse = await fetch(`${API_DESAFIOS_URL}/mis-participaciones`);
                let participaciones = [];
                
                if (participacionesResponse.ok) {
                    try {
                        const participacionesData = await participacionesResponse.json();
                        if (participacionesData && Array.isArray(participacionesData)) {
                            participaciones = participacionesData;
                        } else if (participacionesData && typeof participacionesData === 'object' && Array.isArray(participacionesData.content)) {
                            participaciones = participacionesData.content;
                        } else {
                            console.warn('La respuesta de /mis-participaciones no tiene el formato esperado:', participacionesData);
                            participaciones = [];
                        }
                    } catch (parseError) {
                        console.error('Error al parsear JSON de participaciones:', parseError);
                        participaciones = []; 
                    }
                } else {
                    console.warn(`No se pudieron cargar las participaciones: ${participacionesResponse.status}`);
                }
                
                // Mapear IDs de desafíos en los que participo
                const participacionMap = new Map();
                if (Array.isArray(participaciones)) {
                    participaciones.forEach(p => {
                        if (p && p.desafioId) { 
                           participacionMap.set(p.desafioId, p);
                        } else {
                            console.warn('Participación inválida encontrada:', p);
                        }
                    });
                }
                
                // 2. Obtener todos los desafíos disponibles con paginación
                let desafiosResponse;
                let desafios = [];
                
                try {
                    console.log("Intentando cargar desafíos paginados...");
                                         // Intentar con endpoints potenciales, en orden de preferencia
                     const endpoints = [
                         `${API_DESAFIOS_URL}/paginados?page=${page-1}`,
                         `${API_DESAFIOS_URL}/publicos?page=${page-1}`,
                         `${API_DESAFIOS_URL}?page=${page-1}`,
                         `${API_DESAFIOS_URL}/activos?page=${page-1}`
                     ];
                     
                     let endpointUsado = '';
                     for (const endpoint of endpoints) {
                         try {
                             console.log(`Intentando cargar desafíos desde: ${endpoint}`);
                             const response = await fetch(endpoint);
                             
                             if (response.ok) {
                                 desafiosResponse = response;
                                 endpointUsado = endpoint;
                                 break;
                             }
                         } catch (error) {
                             console.warn(`Error al intentar endpoint ${endpoint}:`, error);
                         }
                     }
                     
                     if (!desafiosResponse) {
                         throw new Error("No se pudo conectar a ningún endpoint de desafíos disponible");
                     }
                     
                     console.log(`Éxito al cargar desafíos desde ${endpointUsado}`);
                     
                     // Intentar obtener información de paginación desde headers
                     let headerTotalItems = desafiosResponse.headers.get('X-Total-Count');
                     let headerTotalPages = desafiosResponse.headers.get('X-Total-Pages');
                     let headerCurrentPage = desafiosResponse.headers.get('X-Current-Page');
                    
                    // Verificar que el tipo de contenido sea JSON
                    const contentType = desafiosResponse.headers.get("content-type");
                    if (!contentType || !contentType.includes("application/json")) {
                        throw new Error("La API está devolviendo HTML en lugar de JSON. Posible problema de sesión o autenticación.");
                    }

                                         const desafiosData = await desafiosResponse.json();
                     
                     // Procesar la respuesta para obtener los desafíos y metadata de paginación
                     if (desafiosData && Array.isArray(desafiosData)) {
                         desafios = desafiosData;
                         // Si no hay headers, asumir que es una sola página
                         if (!headerTotalItems) {
                             challengesTotalItems = desafios.length;
                             challengesTotalPages = 1;
                             challengesCurrentPage = 1; 
                         }
                     } else if (desafiosData && typeof desafiosData === 'object') {
                         if (Array.isArray(desafiosData.content)) {
                             // Formato Spring Data típico
                             desafios = desafiosData.content;
                             
                             if (desafiosData.totalElements !== undefined) challengesTotalItems = desafiosData.totalElements;
                             if (desafiosData.totalPages !== undefined) challengesTotalPages = desafiosData.totalPages;
                             if (desafiosData.number !== undefined) challengesCurrentPage = desafiosData.number + 1;
                             if (desafiosData.size !== undefined) challengesPageSize = desafiosData.size;
                         } else {
                             // Intentar otros formatos comunes
                             if (desafiosData.items && Array.isArray(desafiosData.items)) {
                                 desafios = desafiosData.items;
                                 if (desafiosData.total !== undefined) challengesTotalItems = desafiosData.total;
                                 if (desafiosData.pages !== undefined) challengesTotalPages = desafiosData.pages;
                                 if (desafiosData.page !== undefined) challengesCurrentPage = desafiosData.page;
                             } else {
                                 console.warn('Formato de respuesta no reconocido:', desafiosData);
                                 desafios = [];
                             }
                         }
                     } else {
                         console.warn('Formato de respuesta inesperado:', desafiosData);
                         desafios = [];
                     }
                     
                     // Si hay headers de paginación, usarlos (prioridad sobre datos en cuerpo)
                     if (headerTotalItems) challengesTotalItems = parseInt(headerTotalItems);
                     if (headerTotalPages) challengesTotalPages = parseInt(headerTotalPages);
                     if (headerCurrentPage) challengesCurrentPage = parseInt(headerCurrentPage) + 1;
                     
                     // Asegurar valores mínimos válidos
                     challengesTotalItems = challengesTotalItems || desafios.length;
                     challengesTotalPages = challengesTotalPages || 1;
                     challengesCurrentPage = challengesCurrentPage || 1;

                } catch (error) {
                    console.error(`Error al conectar con la API de desafíos: ${error.message}`);
                    throw error;
                }
                
                // Actualizar controles de paginación
                updateChallengesPaginationControls();
                
                // 3. Unir los datos y renderizar
                challengesGrid.innerHTML = '';
                if (desafios.length === 0) {
                    challengesGrid.innerHTML = '<p>No hay desafíos disponibles en esta página.</p>';
                    return;
                }
                
                // Procesar cada desafío y añadirle su participación si existe
                const desafiosProcesados = desafios.map(desafio => {
                    if (!desafio || typeof desafio !== 'object') {
                        console.warn("Elemento inválido encontrado en la lista de desafíos:", desafio);
                        return null;
                    }
                    
                    const desafioConParticipacion = { ...desafio };
                    
                    if (participacionMap.has(desafio.id)) {
                        desafioConParticipacion.participacion = participacionMap.get(desafio.id);
                    }
                    
                    if (!desafioConParticipacion.proyectoNombre && desafioConParticipacion.proyectoId) {
                        desafioConParticipacion.proyectoNombre = `Proyecto ${desafioConParticipacion.proyectoId}`;
                    }
                    return desafioConParticipacion;
                }).filter(d => d !== null);
                
                // Renderizar desafíos
                desafiosProcesados.forEach((desafio, index) => {
                    setTimeout(() => {
                        renderChallengeCard(desafio);
                    }, 100 * index); 
                });
                
            } catch (error) {
                console.error('Error al cargar desafíos:', error);
                
                let errorMessage = error.message;
                let showLoginButton = errorMessage.includes("sesión") || errorMessage.includes("autenticación");
                
                challengesGrid.innerHTML = `
                    <div style="text-align: center; padding: 20px;">
                        <p>Error al cargar desafíos: ${errorMessage}</p>
                        ${showLoginButton ? 
                            `<button class="login-btn" onclick="window.location.href='/login'" style="
                                margin-top: 15px;
                                padding: 10px 20px;
                                background: var(--primary-color);
                                color: white;
                                border: none;
                                border-radius: 4px;
                                cursor: pointer;
                                font-weight: bold;
                            ">
                                <i class="fas fa-sign-in-alt"></i> Iniciar Sesión
                            </button>` 
                            : 
                            `<button class="retry-btn" onclick="loadChallengesPaginated(1)" style="
                                margin-top: 10px;
                                padding: 8px 16px;
                                background: var(--primary-color);
                                color: white;
                                border: none;
                                border-radius: 4px;
                                cursor: pointer;
                            ">Reintentar</button>`
                        }
                    </div>`;
            }
        }

        // --- ACTUALIZAR CONTROLES DE PAGINACIÓN ---
        function updatePaginationControls() {
            // Asegurar valores válidos para evitar problemas de visualización
            currentPage = Math.min(Math.max(1, currentPage), totalPages || 1);
            totalPages = Math.max(1, totalPages);
            totalItems = Math.max(0, totalItems);
            
            // Actualizar texto de información 
            currentPageElement.textContent = currentPage;
            totalPagesElement.textContent = totalPages;
            totalItemsElement.textContent = new Intl.NumberFormat().format(totalItems);
            
            // Actualizar mensaje informativo para grandes cantidades
            const paginationStatus = document.getElementById('pagination-status');
            if (paginationStatus) {
                if (totalPages > 100) {
                    paginationStatus.innerHTML = `Mostrando página <strong>${currentPage}</strong> de <strong>${totalPages}</strong>`;
                } else {
                    paginationStatus.textContent = `Mostrando página ${currentPage} de ${totalPages}`;
                }
            }
            
            // Habilitar/deshabilitar botones según la página actual
            prevPageButton.disabled = currentPage <= 1;
            nextPageButton.disabled = currentPage >= totalPages;
            
            // Generar números de página de manera inteligente
            generatePageNumbers(pageNumbersContainer, currentPage, totalPages, page => loadDataAndRender(page));
            
            // Mostrar u ocultar la paginación según sea necesario
            paginationContainer.style.display = (totalPages <= 1) ? 'none' : 'flex';
        }
        
        function updateChallengesPaginationControls() {
            // Asegurar valores válidos
            challengesCurrentPage = Math.min(Math.max(1, challengesCurrentPage), challengesTotalPages || 1);
            challengesTotalPages = Math.max(1, challengesTotalPages);
            challengesTotalItems = Math.max(0, challengesTotalItems);
            
            // Actualizar texto de información
            challengesCurrentPageElement.textContent = challengesCurrentPage;
            challengesTotalPagesElement.textContent = challengesTotalPages;
            challengesTotalItemsElement.textContent = new Intl.NumberFormat().format(challengesTotalItems);
            
            // Actualizar mensaje informativo para grandes cantidades
            const paginationStatus = document.getElementById('challenges-pagination-status');
            if (paginationStatus) {
                if (challengesTotalPages > 100) {
                    paginationStatus.innerHTML = `Mostrando página <strong>${challengesCurrentPage}</strong> de <strong>${challengesTotalPages}</strong>`;
                } else {
                    paginationStatus.textContent = `Mostrando página ${challengesCurrentPage} de ${challengesTotalPages}`;
                }
            }
            
            // Habilitar/deshabilitar botones según la página actual
            challengesPrevPageButton.disabled = challengesCurrentPage <= 1;
            challengesNextPageButton.disabled = challengesCurrentPage >= challengesTotalPages;
            
            // Generar números de página de manera inteligente
            generatePageNumbers(challengesPageNumbersContainer, challengesCurrentPage, challengesTotalPages, 
                              page => loadChallengesPaginated(page));
            
            // Mostrar u ocultar la paginación según sea necesario
            challengesPaginationContainer.style.display = (challengesTotalPages <= 1) ? 'none' : 'flex';
        }
        
        // Función para generar los números de página de manera inteligente
        function generatePageNumbers(container, currentPage, totalPages, clickHandler) {
            container.innerHTML = '';
            
            // Si hay muchas páginas, limitar el número mostrado
            const maxPagesToShow = 5; // Número máximo de páginas a mostrar en el centro
            const maxTotalButtons = 9; // Máximo total de botones incluyendo primera/última página y elipsis
            
            // Caso especial: pocas páginas totales, mostrarlas todas
            if (totalPages <= maxTotalButtons) {
                for (let i = 1; i <= totalPages; i++) {
                    addPageNumber(container, i, currentPage, clickHandler);
                }
                return;
            }
            
            // Caso normal: muchas páginas, mostrar de forma selectiva
            
            // Siempre mostrar primera página
            addPageNumber(container, 1, currentPage, clickHandler);
            
            // Calcular rango central de páginas a mostrar
            let centralStart = Math.max(2, currentPage - Math.floor(maxPagesToShow / 2));
            let centralEnd = Math.min(totalPages - 1, centralStart + maxPagesToShow - 1);
            
            // Ajustar el inicio si estamos cerca del final
            if (centralEnd === totalPages - 1) {
                centralStart = Math.max(2, centralEnd - maxPagesToShow + 1);
            }
            
            // Mostrar elipsis antes del rango central si es necesario
            if (centralStart > 2) {
                const ellipsis = document.createElement('span');
                ellipsis.textContent = '...';
                ellipsis.className = 'page-ellipsis';
                container.appendChild(ellipsis);
            }
            
            // Mostrar el rango central de páginas
            for (let i = centralStart; i <= centralEnd; i++) {
                addPageNumber(container, i, currentPage, clickHandler);
            }
            
            // Mostrar elipsis después del rango central si es necesario
            if (centralEnd < totalPages - 1) {
                const ellipsis = document.createElement('span');
                ellipsis.textContent = '...';
                ellipsis.className = 'page-ellipsis';
                container.appendChild(ellipsis);
            }
            
            // Siempre mostrar última página
            addPageNumber(container, totalPages, currentPage, clickHandler);
        }
        
        function addPageNumber(container, pageNum, currentPage, clickHandler) {
            const pageBtn = document.createElement('div');
            pageBtn.className = 'page-number' + (pageNum === currentPage ? ' active' : '');
            pageBtn.textContent = pageNum;
            pageBtn.addEventListener('click', () => clickHandler(pageNum));
            container.appendChild(pageBtn);
        }

        // --- BÚSQUEDA PAGINADA ---
        async function searchItems() {
            const query = document.getElementById('userSearchInput').value;
            
            if (activeTab === 'projects') {
                await searchProjectsPaginated(query);
            } else {
                await searchChallengesPaginated(query);
            }
        }
        
        async function searchProjectsPaginated(query, page = 1) {
            projectsGrid.innerHTML = '<p>Buscando...</p>';

            try {
                let url;
                if (query) {
                    url = `${API_PROYECTOS_URL}/buscar?nombre=${encodeURIComponent(query)}&page=${page-1}&size=${pageSize}`;
                } else {
                    url = `${API_PROYECTOS_URL}?page=${page-1}&size=${pageSize}`;
                }

                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Error HTTP: ${response.status}`);
                }
                
                // Obtener información de paginación
                totalItems = parseInt(response.headers.get('X-Total-Count') || '0');
                totalPages = parseInt(response.headers.get('X-Total-Pages') || '1');
                currentPage = parseInt(response.headers.get('X-Current-Page') || '0') + 1;
                
                const responseData = await response.json();
                
                // Actualizar controles de paginación
                updatePaginationControls();
                
                // Determinar si la respuesta es un objeto paginado o un array directo
                let projects;
                if (responseData && Array.isArray(responseData)) {
                    projects = responseData;
                } else if (responseData && typeof responseData === 'object' && Array.isArray(responseData.content)) {
                    projects = responseData.content;
                    // Si no tenemos totalItems de los headers, usar datos de paginación del objeto
                    if (totalItems === 0 && responseData.totalElements) {
                        totalItems = responseData.totalElements;
                        totalPages = responseData.totalPages || Math.ceil(responseData.totalElements / pageSize);
                        currentPage = responseData.number + 1 || 1;
                        updatePaginationControls();
                    }
                } else {
                    console.warn('Formato de respuesta inesperado:', responseData);
                    projects = [];
                }
                
                renderAllProjects(projects);
            } catch (error) {
                console.error('Error al buscar proyectos:', error);
                projectsGrid.innerHTML = '<p>Error al realizar la búsqueda. Intente de nuevo.</p>';
            }
        }
        
        async function searchChallengesPaginated(query, page = 1) {
            // Implementación similar a loadChallengesPaginated pero con filtro de búsqueda
            challengesGrid.innerHTML = '<p>Buscando...</p>';
            
            try {
                let url;
                if (query) {
                    url = `${API_DESAFIOS_URL}/buscar?nombre=${encodeURIComponent(query)}&page=${page-1}&size=${challengesPageSize}`;
                } else {
                    url = `${API_DESAFIOS_URL}/paginados?page=${page-1}&size=${challengesPageSize}`;
                }
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    // Si falla el endpoint específico de búsqueda, cargar todos y filtrar en cliente
                    if (query) {
                        await loadChallengesPaginated(page);
                        
                        // Filtrar los desafíos mostrados según el query
                        const cards = challengesGrid.querySelectorAll('.challenge-card');
                        const queryLower = query.toLowerCase();
                        let visibleCount = 0;
                        
                        cards.forEach(card => {
                            const title = card.querySelector('.challenge-title').textContent;
                            const desc = card.querySelector('.challenge-description').textContent;
                            const matchesQuery = title.toLowerCase().includes(queryLower) || 
                                             desc.toLowerCase().includes(queryLower);
                            
                            if (matchesQuery) {
                                card.style.display = 'flex';
                                visibleCount++;
                            } else {
                                card.style.display = 'none';
                            }
                        });
                        
                        if (visibleCount === 0) {
                            challengesGrid.innerHTML = `<p>No se encontraron desafíos que coincidan con "${query}"</p>`;
                        }
                        
                        return;
                    }
                    
                    throw new Error(`Error ${response.status} obteniendo desafíos`);
                }
                
                // Similar a loadChallengesPaginated, procesar la respuesta...
                // Obtener información de paginación
                challengesTotalItems = parseInt(response.headers.get('X-Total-Count') || '0');
                challengesTotalPages = parseInt(response.headers.get('X-Total-Pages') || '1');
                challengesCurrentPage = parseInt(response.headers.get('X-Current-Page') || '0') + 1;
                
                const responseData = await response.json();
                
                let desafios;
                if (responseData && Array.isArray(responseData)) {
                    desafios = responseData;
                } else if (responseData && typeof responseData === 'object' && Array.isArray(responseData.content)) {
                    desafios = responseData.content;
                    // Si no tenemos totalItems de los headers, usar datos de paginación del objeto
                    if (challengesTotalItems === 0 && responseData.totalElements) {
                        challengesTotalItems = responseData.totalElements;
                        challengesTotalPages = responseData.totalPages || Math.ceil(responseData.totalElements / challengesPageSize);
                        challengesCurrentPage = responseData.number + 1 || 1;
                    }
                } else {
                    console.warn('Formato de respuesta inesperado:', responseData);
                    desafios = [];
                }
                
                // Actualizar controles de paginación
                updateChallengesPaginationControls();
                
                // Cargar participaciones y renderizar como en loadChallengesPaginated
                const participacionesResponse = await fetch(`${API_DESAFIOS_URL}/mis-participaciones`);
                const participacionMap = new Map();
                
                if (participacionesResponse.ok) {
                    const participacionesData = await participacionesResponse.json();
                    const participaciones = Array.isArray(participacionesData) ? 
                        participacionesData : 
                        (participacionesData.content || []);
                    
                    participaciones.forEach(p => {
                        if (p && p.desafioId) {
                            participacionMap.set(p.desafioId, p);
                        }
                    });
                }
                
                // Procesamiento y renderizado de desafíos
                challengesGrid.innerHTML = '';
                
                if (desafios.length === 0) {
                    challengesGrid.innerHTML = `<p>No se encontraron desafíos${query ? ` que coincidan con "${query}"` : ''}.</p>`;
                    return;
                }
                
                // Combinar con participaciones y renderizar
                const desafiosProcesados = desafios.map(desafio => {
                    const desafioConParticipacion = { ...desafio };
                    
                    if (participacionMap.has(desafio.id)) {
                        desafioConParticipacion.participacion = participacionMap.get(desafio.id);
                    }
                    
                    if (!desafioConParticipacion.proyectoNombre && desafioConParticipacion.proyectoId) {
                        desafioConParticipacion.proyectoNombre = `Proyecto ${desafioConParticipacion.proyectoId}`;
                    }
                    
                    return desafioConParticipacion;
                });
                
                // Renderizar desafíos procesados
                desafiosProcesados.forEach((desafio, index) => {
                    setTimeout(() => renderChallengeCard(desafio), 50 * index);
                });
                
            } catch (error) {
                console.error('Error al buscar desafíos:', error);
                challengesGrid.innerHTML = `<p>Error al buscar desafíos: ${error.message}</p>`;
            }
        }

        // --- INICIALIZACIÓN Y EVENT LISTENERS ---
        document.addEventListener('DOMContentLoaded', () => {
            // Inicializar variable que almacenará proyectos en los que participo
            window.currentUserProjects = [];
            
            // Intentar cargar proyectos desde localStorage primero
            const loadedFromStorage = loadUserProjectsFromLocalStorage();
            
            // Configurar event listeners para paginación de proyectos
            prevPageButton.addEventListener('click', () => {
                if (currentPage > 1) {
                    loadDataAndRender(currentPage - 1);
                }
            });
            
            nextPageButton.addEventListener('click', () => {
                if (currentPage < totalPages) {
                    loadDataAndRender(currentPage + 1);
                }
            });
            
            // Configurar event listeners para paginación de desafíos
            challengesPrevPageButton.addEventListener('click', () => {
                if (challengesCurrentPage > 1) {
                    loadChallengesPaginated(challengesCurrentPage - 1);
                }
            });
            
            challengesNextPageButton.addEventListener('click', () => {
                if (challengesCurrentPage < challengesTotalPages) {
                    loadChallengesPaginated(challengesCurrentPage + 1);
                }
            });
            
            // Si se cargaron proyectos desde localStorage, renderizar de inmediato
            if (loadedFromStorage) {
                console.log('Usando proyectos de localStorage:', currentUserProjects);
                loadDataAndRender();
            }
            
            // Event listeners para pestañas
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    switchTab(button.dataset.tab);
                });
            });
            
            // Event listeners para filtros
            document.querySelectorAll('.filter-section').forEach(section => {
                section.querySelectorAll('.filter-btn').forEach(button => {
                    button.addEventListener('click', () => {
                        section.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                        button.classList.add('active');
                        applyFilter();
                    });
                });
            });
            
            // Listener para búsqueda
            const searchButton = document.querySelector('.search-btn');
            if (searchButton) {
                searchButton.addEventListener('click', searchItems);
            }
            
            // Permitir búsqueda al presionar Enter
            const searchInput = document.getElementById('userSearchInput');
            if (searchInput) {
                searchInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        searchItems();
                    }
                });
            }
            
            // Cargar primera página de proyectos
            loadDataAndRender();
        });

        // --- FILTRADO --- 
        function applyFilter() {
            const container = activeTab === 'projects' ? projectsFilters : challengesFilters;
            const activeFilterButton = container.querySelector('.filter-btn.active');
            const filter = activeFilterButton ? activeFilterButton.dataset.filter : 'all';
            
            const cards = activeTab === 'projects' 
                ? projectsGrid.querySelectorAll('.project-user-card')
                : challengesGrid.querySelectorAll('.challenge-card');

            cards.forEach(card => {
                card.style.opacity = '0';
                card.style.transform = 'translateY(20px)';
                card.classList.remove('show');
                
                if (filter === 'all' || card.dataset.category === filter) {
                    card.style.display = 'flex';
                    setTimeout(() => {
                        card.style.opacity = '1';
                        card.style.transform = 'translateY(0)';
                        card.classList.add('show');
                    }, 10);
                } else {
                    card.style.display = 'none';
                }
            });
        }

        // --- ACCIONES DE DESAFÍO ---
        async function participateInChallenge(challengeId) {
            try {
                const response = await fetch(`${API_DESAFIOS_URL}/${challengeId}/participar`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    const errorData = await response.text();
                    throw new Error(`Error: ${errorData}`);
                }
                
                // Recargar desafíos para reflejar el cambio
                loadChallengesPaginated();
                
            } catch (error) {
                console.error('Error al participar en el desafío:', error);
                alert(`No se pudo participar en el desafío: ${error.message}`);
            }
        }
        
        async function completeChallenge(challengeId) {
            try {
                // Mostrar un indicador de carga mientras se procesa
                const card = document.querySelector(`.challenge-card[data-challenge-id="${challengeId}"]`);
                const actionButton = card.querySelector('.complete-btn');
                const originalButtonHtml = actionButton.innerHTML;
                actionButton.disabled = true;
                actionButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Procesando...';
                
                // Verificar primero la autenticación
                try {
                    const authResponse = await fetch('/api/usuarios/me', {
                        method: 'GET',
                        credentials: 'include',
                        headers: {
                            'X-Requested-With': 'XMLHttpRequest',
                            'Accept': 'application/json',
                            'Cache-Control': 'no-cache, no-store'
                        }
                    });
                    
                    if (!authResponse.ok) {
                        throw new Error('Tu sesión ha expirado. Por favor, recarga la página e inicia sesión nuevamente.');
                    }
                } catch (authError) {
                    console.error('Error de autenticación:', authError);
                    showNotification('Tu sesión ha expirado. Por favor, recarga la página e inicia sesión nuevamente.', 'error');
                    
                    // Opcional: redirigir al login después de mostrar la notificación
                    setTimeout(() => {
                        window.location.href = '/login?redirectTo=' + encodeURIComponent(window.location.pathname);
                    }, 2000);
                    
                    // Restaurar el botón
                    actionButton.disabled = false;
                    actionButton.innerHTML = originalButtonHtml;
                    return;
                }
                
                // Ejecutar la petición para completar el desafío
                const response = await fetch(`/api/desafios/${challengeId}/completar`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest',
                        'Accept': 'application/json'
                    },
                    credentials: 'include',
                    cache: 'no-cache'
                });
                
                // Restaurar el botón
                actionButton.disabled = false;
                actionButton.innerHTML = originalButtonHtml;
                
                // Procesar la respuesta
                if (!response.ok) {
                    // Manejar errores
                    const contentType = response.headers.get('content-type');
                    let errorMessage = `Error ${response.status}`;
                    
                    if (contentType && contentType.includes('application/json')) {
                        const errorData = await response.json();
                        errorMessage = errorData.error || errorData.mensaje || errorData.message || errorMessage;
                    } else {
                        const errorText = await response.text();
                        
                        if (errorText.includes('<!DOCTYPE') || errorText.includes('<html')) {
                            errorMessage = 'Tu sesión ha expirado. Por favor, recarga la página e inicia sesión nuevamente.';
                            
                            // Redirigir al login después de mostrar la notificación
                            setTimeout(() => {
                                window.location.href = '/login?redirectTo=' + encodeURIComponent(window.location.pathname);
                            }, 2000);
                        } else {
                            errorMessage = errorText || errorMessage;
                        }
                    }
                    
                    throw new Error(errorMessage);
                }
                
                // Manejar respuesta exitosa
                let result;
                const contentType = response.headers.get('content-type');
                
                if (contentType && contentType.includes('application/json')) {
                    result = await response.json();
                } else {
                    result = { mensaje: await response.text() };
                }
                
                // Mostrar mensaje de éxito
                showNotification(result.mensaje || '¡Desafío completado con éxito!', 'success');
                
                // Actualizar la tarjeta antes de recargar
                card.classList.remove('active');
                card.classList.add('completed');
                const progressBar = card.querySelector('.progress');
                if (progressBar) progressBar.style.width = '100%';
                
                // Recargar después de un momento
                setTimeout(() => loadChallengesPaginated(), 1000);
            } catch (error) {
                console.error('Error al completar el desafío:', error);
                showNotification(`No se pudo completar el desafío: ${error.message}`, 'error');
            }
        }

        // --- ACCIONES DE PROYECTO (Unirse/Abandonar) ---
        async function joinProject(projectId) {
            try {
                // Verificar primero si ya estoy participando para evitar errores
                const yaParticipo = await verificarParticipacionEnProyecto(projectId);
                if (yaParticipo) {
                    // Si ya participo, actualizar la interfaz sin intentar unirse de nuevo
                    if (!currentUserProjects.includes(projectId)) {
                        currentUserProjects.push(projectId);
                        saveUserProjectsToLocalStorage();
                    }
                    
                    // Recargar los datos del proyecto
                    const proyectoResponse = await fetch(`${API_PROYECTOS_URL}/${projectId}`);
                    if (proyectoResponse.ok) {
                        const projectData = await proyectoResponse.json();
                        
                        // Actualizar tarjetas
                        const cards = document.querySelectorAll(`.project-user-card[data-project-id="${projectId}"]`);
                        cards.forEach(card => {
                            renderProjectCardContent(card, projectData, true);
                        });
                        
                        // Mostrar mensaje informativo
                        showNotification('info', 'Ya estás participando en este proyecto');
                        return;
                    }
                }
                
                // Primero, verificar si el proyecto está lleno antes de intentar unirse
                try {
                    const projectResponse = await fetch(`${API_PROYECTOS_URL}/${projectId}`);
                    if (projectResponse.ok) {
                        const projectData = await projectResponse.json();
                        
                        // Verificar si está completo o ha alcanzado el límite
                        if (projectData.estado === 'COMPLETO' || 
                            (projectData.participantesActuales !== null && 
                             projectData.limiteParticipantes !== null && 
                             projectData.participantesActuales >= projectData.limiteParticipantes)) {
                            
                            showNotification('warning', 'El proyecto está completo y no admite más participantes');
                            
                            // Actualizar la UI para mostrar el proyecto como completo
                            const cards = document.querySelectorAll(`.project-user-card[data-project-id="${projectId}"]`);
                            cards.forEach(card => {
                                renderProjectCardContent(card, projectData, false);
                            });
                            
                            return;
                        }
                    }
                } catch (error) {
                    console.warn('Error al verificar estado del proyecto:', error);
                    // Continuar de todos modos e intentar unirse
                }
                
                // Si no participo, continuar con la lógica normal
                // Deshabilitar botones durante la acción para evitar clicks múltiples
                const buttons = document.querySelectorAll('.join-project-btn, .leave-project-btn');
                buttons.forEach(btn => btn.disabled = true);
                
                // Enviar la solicitud al servidor
                const rol = 'VOLUNTARIO'; // Rol por defecto
                const response = await fetch(`${API_PROYECTOS_URL}/${projectId}/unirse?rol=${rol}`, {
                    method: 'POST'
                });
                
                // Verificar si la respuesta fue exitosa
                if (!response.ok) {
                    const contentType = response.headers.get("content-type");
                    
                    // Manejar específicamente el caso de proyecto completo (409 Conflict)
                    if (response.status === 409) {
                        // Obtener datos actualizados del proyecto
                        const proyectoResponse = await fetch(`${API_PROYECTOS_URL}/${projectId}`);
                        if (proyectoResponse.ok) {
                            const projectData = await proyectoResponse.json();
                            
                            // Actualizar la UI sin mostrar error
                            const cards = document.querySelectorAll(`.project-user-card[data-project-id="${projectId}"]`);
                            cards.forEach(card => {
                                renderProjectCardContent(card, projectData, false);
                            });
                            
                            // Intentar obtener el mensaje específico del error
                            let errorMsg = 'El proyecto está completo y no admite más participantes';
                            try {
                                const errorText = await response.text();
                                if (errorText && errorText.length > 0) {
                                    // Intentar parsear como JSON primero
                                    try {
                                        const jsonError = JSON.parse(errorText);
                                        if (jsonError.message) {
                                            errorMsg = jsonError.message;
                                        }
                                    } catch (e) {
                                        // Si no es JSON, usar el texto tal cual si no parece HTML
                                        if (!errorText.includes('<!DOCTYPE') && !errorText.includes('<html')) {
                                            errorMsg = errorText;
                                        }
                                    }
                                }
                            } catch (e) {
                                // Si hay error al leer la respuesta, mantener el mensaje por defecto
                                console.warn('Error al leer respuesta de error:', e);
                            }
                            
                            showNotification('warning', errorMsg);
                            return;
                        } else {
                            throw new Error('El proyecto está completo o no admite más participantes');
                        }
                    }
                    
                    // Para otros errores, proceder normalmente
                    if (contentType && contentType.indexOf("application/json") !== -1) {
                        // Si el servidor responde con JSON, manejar el error como JSON
                        const error = await response.json();
                        throw new Error(error.message || 'Error al unirse al proyecto');
                    } else {
                        // Si el servidor responde con texto, manejar el error como texto
                        const errorText = await response.text();
                        throw new Error(errorText || `Error ${response.status}: ${response.statusText}`);
                    }
                }
                
                // Intentar procesar la respuesta como JSON o como texto
                let mensaje;
                const contentType = response.headers.get("content-type");
                if (contentType && contentType.indexOf("application/json") !== -1) {
                    const data = await response.json();
                    mensaje = data.mensaje || 'Te has unido al proyecto exitosamente';
                } else {
                    mensaje = await response.text();
                }
                
                // Actualizar estado local
                if (!currentUserProjects.includes(projectId)) {
                    currentUserProjects.push(projectId);
                    // Guardar en localStorage
                    saveUserProjectsToLocalStorage();
                }
                
                // Re-obtener los datos actualizados del proyecto
                const proyectoResponse = await fetch(`${API_PROYECTOS_URL}/${projectId}`);
                if (!proyectoResponse.ok) {
                    throw new Error('Error al obtener datos actualizados del proyecto');
                }
                
                const projectData = await proyectoResponse.json();
                
                // Actualizar todas las tarjetas de este proyecto
                const cards = document.querySelectorAll(`.project-user-card[data-project-id="${projectId}"]`);
                cards.forEach(card => {
                    renderProjectCardContent(card, projectData, true); // Ahora ESTOY participando
                });
                
                // También actualizar el modal si está abierto
                const projectModal = document.getElementById('projectModal');
                if (projectModal && projectModal.classList.contains('show') && 
                    projectModal.dataset.projectId === projectId) {
                    updateProjectActions(projectData);
                }
                
                // Mostrar mensaje de éxito
                showNotification('success', mensaje);
                
                // Reaplicar filtro actual
                applyFilter();
                
            } catch (error) {
                console.error('Error al unirse al proyecto:', error);
                showNotification('error', error.message || 'Error al unirse al proyecto');
            } finally {
                // Re-habilitar botones
                const buttons = document.querySelectorAll('.join-project-btn, .leave-project-btn');
                buttons.forEach(btn => btn.disabled = false);
            }
        }
        
        // Función auxiliar para mostrar mensajes
        function showMessage(type, title, message) {
            // Si tienes una librería de notificaciones, úsala aquí
            // Por ejemplo, sweetalert2:
            if (window.Swal) {
                Swal.fire({
                    icon: type,
                    title: title,
                    text: message
                });
            } else {
                // Fallback a alert nativo
                alert(message);
            }
        }
        
        // Función para mostrar notificaciones
        function showNotification(type, message) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `
                <span>${message}</span>
                <button class="close-notification">&times;</button>
            `;
            
            document.body.appendChild(notification);
            
            // Mostrar notificación
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);
            
            // Ocultar después de 3 segundos
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
            
            // Configurar botón para cerrar
            notification.querySelector('.close-notification').addEventListener('click', () => {
                notification.classList.remove('show');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            });
        }
        
        // Función para actualizar la UI cuando el usuario se une/abandona un proyecto
        function updateProjectParticipation(projectId, isParticipating) {
            // Actualizar la tarjeta del proyecto en la vista principal
            const projectCard = document.querySelector(`.project-user-card[data-project-id="${projectId}"]`);
            if (projectCard) {
                const project = window.projectsData.find(p => p.id === projectId);
                if (project) {
                    renderProjectCardContent(projectCard, project, isParticipating);
                }
            }
            
            // Actualizar los filtros si es necesario
            applyFilter();
        }

         async function leaveProject(projectId) {
            if (!confirm('¿Seguro que quieres abandonar este proyecto?')) return;

            try {
                // Antes de intentar abandonar, verificar si realmente estamos participando
                const participando = await verificarParticipacionEnProyecto(projectId);
                if (!participando) {
                    // Si no estamos participando según el servidor, solo actualizar la UI local
                    console.log(`No estás participando en el proyecto ${projectId} según el servidor, actualizando UI local`);
                    
                    // Eliminar de la lista local de proyectos
                    currentUserProjects = currentUserProjects.filter(id => id !== projectId);
                    saveUserProjectsToLocalStorage();
                    
                    // Recargar datos del proyecto
                    const proyectoResponse = await fetch(`${API_PROYECTOS_URL}/${projectId}`);
                    if (proyectoResponse.ok) {
                        const projectData = await proyectoResponse.json();
                        
                        // Actualizar tarjetas
                        const cards = document.querySelectorAll(`.project-user-card[data-project-id="${projectId}"]`);
                        cards.forEach(card => {
                            renderProjectCardContent(card, projectData, false);
                        });
                        
                        // Mostrar mensaje
                        showNotification('info', 'Ya no participas en este proyecto');
                        
                        // Reaplicar filtro
                        applyFilter();
                        return;
                    }
                }
                
                // Si participamos, continuar con la lógica normal
                const response = await fetch(`${API_PROYECTOS_URL}/${projectId}/abandonar`, {
                    method: 'DELETE',
                    headers: { 
                        // Headers de autenticación si son necesarios 
                    }
                });

                // Manejar los casos específicos de error
                if (!response.ok) {
                    // Para error 404 (no encontrado) o 409 (conflicto por no participar)
                    if (response.status === 404 || response.status === 409) {
                        console.log(`Error ${response.status} al abandonar el proyecto ${projectId} - actualizando estado local`);
                        
                        // Actualizar el estado local aunque el servidor reportó error
                        currentUserProjects = currentUserProjects.filter(id => id !== projectId);
                        saveUserProjectsToLocalStorage();
                        
                        // Obtener datos actualizados del proyecto
                        const proyectoResponse = await fetch(`${API_PROYECTOS_URL}/${projectId}`);
                        if (proyectoResponse.ok) {
                            const projectData = await proyectoResponse.json();
                            
                            // Actualizar todas las tarjetas de este proyecto
                            const cards = document.querySelectorAll(`.project-user-card[data-project-id="${projectId}"]`);
                            cards.forEach(card => {
                                renderProjectCardContent(card, projectData, false);
                            });
                            
                            // Mostrar notificación informativa
                            showNotification('info', 'Ya no estás participando en este proyecto');
                            
                            // Reaplicar filtro actual
                            applyFilter();
                            return;
                        } else {
                            throw new Error(`No se pudo obtener información actualizada del proyecto`);
                        }
                    } else {
                        // Para otros errores, intentar extraer mensaje
                        const contentType = response.headers.get("content-type");
                        let errorMsg = `Error ${response.status} al abandonar el proyecto`;
                        
                        try {
                            const errorText = await response.text();
                            
                            // Si es JSON, intentar extraer mensaje
                            if (contentType && contentType.indexOf("application/json") !== -1) {
                                try {
                                    const errorData = JSON.parse(errorText);
                                    errorMsg = errorData.message || errorData.error || errorMsg;
                                } catch (e) {
                                    // Si falla el parse de JSON, usar el texto tal cual
                                    errorMsg = errorText;
                                }
                            } else if (errorText && !errorText.includes('<!DOCTYPE') && !errorText.includes('<html')) {
                                // Si no es HTML, usar el texto tal cual
                                errorMsg = errorText;
                            }
                        } catch (e) {
                            console.warn("Error al leer respuesta de error:", e);
                        }
                        
                        throw new Error(errorMsg);
                    }
                }

                // Actualizar UI
                currentUserProjects = currentUserProjects.filter(id => id !== projectId); // Actualizar estado local
                // Guardar en localStorage
                saveUserProjectsToLocalStorage();
                
                // Re-obtener los datos actualizados del proyecto para reflejar el cambio en participantesActuales
                const proyectoResponse = await fetch(`${API_PROYECTOS_URL}/${projectId}`);
                if (!proyectoResponse.ok) {
                    throw new Error('Error al obtener datos actualizados del proyecto');
                }
                
                const projectData = await proyectoResponse.json();
                
                // Actualizar todas las tarjetas de este proyecto
                const cards = document.querySelectorAll(`.project-user-card[data-project-id="${projectId}"]`);
                cards.forEach(card => {
                    renderProjectCardContent(card, projectData, false); // Ahora NO estoy participando
                });
                
                // También actualizar el modal si está abierto
                const projectModal = document.getElementById('projectModal');
                if (projectModal && projectModal.classList.contains('show') && 
                    projectModal.dataset.projectId === projectId) {
                    
                    // Verificar si la función updateProjectActions y el container existen
                    const actionsContainer = document.getElementById('modal-project-actions');
                    if (typeof updateProjectActions === 'function' && actionsContainer) {
                        updateProjectActions(projectData);
                    }
                }
                
                // Mostrar notificación de éxito
                showNotification('success', 'Has abandonado el proyecto exitosamente');
                
                // Reaplicar filtro actual
                applyFilter();
            } catch (error) {
                console.error('Error al abandonar el proyecto:', error);
                showNotification(`No se pudo abandonar el proyecto: ${error.message}`, 'error');
            }
        }

        // --- BÚSQUEDA ---
        async function searchItems() {
            const query = document.getElementById('userSearchInput').value;
            
            if (activeTab === 'projects') {
                await searchProjectsPaginated(query);
            } else {
                await searchChallengesPaginated(query);
            }
        }
        
        async function searchProjectsPaginated(query, page = 1) {
            projectsGrid.innerHTML = '<p>Buscando...</p>';

            try {
                let url;
                if (query) {
                    url = `${API_PROYECTOS_URL}/buscar?nombre=${encodeURIComponent(query)}&page=${page-1}&size=${pageSize}`;
                } else {
                    url = `${API_PROYECTOS_URL}?page=${page-1}&size=${pageSize}`;
                }

                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Error HTTP: ${response.status}`);
                }
                
                // Obtener información de paginación
                totalItems = parseInt(response.headers.get('X-Total-Count') || '0');
                totalPages = parseInt(response.headers.get('X-Total-Pages') || '1');
                currentPage = parseInt(response.headers.get('X-Current-Page') || '0') + 1;
                
                const responseData = await response.json();
                
                // Actualizar controles de paginación
                updatePaginationControls();
                
                // Determinar si la respuesta es un objeto paginado o un array directo
                let projects;
                if (responseData && Array.isArray(responseData)) {
                    projects = responseData;
                } else if (responseData && typeof responseData === 'object' && Array.isArray(responseData.content)) {
                    projects = responseData.content;
                    // Si no tenemos totalItems de los headers, usar datos de paginación del objeto
                    if (totalItems === 0 && responseData.totalElements) {
                        totalItems = responseData.totalElements;
                        totalPages = responseData.totalPages || Math.ceil(responseData.totalElements / pageSize);
                        currentPage = responseData.number + 1 || 1;
                        updatePaginationControls();
                    }
                } else {
                    console.warn('Formato de respuesta inesperado:', responseData);
                    projects = [];
                }
                
                renderAllProjects(projects);
            } catch (error) {
                console.error('Error al buscar proyectos:', error);
                projectsGrid.innerHTML = '<p>Error al realizar la búsqueda. Intente de nuevo.</p>';
            }
        }
        
        async function searchChallengesPaginated(query, page = 1) {
            // Implementación similar a loadChallengesPaginated pero con filtro de búsqueda
            challengesGrid.innerHTML = '<p>Buscando...</p>';
            
            try {
                let url;
                if (query) {
                    url = `${API_DESAFIOS_URL}/buscar?nombre=${encodeURIComponent(query)}&page=${page-1}&size=${challengesPageSize}`;
                } else {
                    url = `${API_DESAFIOS_URL}/paginados?page=${page-1}&size=${challengesPageSize}`;
                }
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    // Si falla el endpoint específico de búsqueda, cargar todos y filtrar en cliente
                    if (query) {
                        await loadChallengesPaginated(page);
                        
                        // Filtrar los desafíos mostrados según el query
                        const cards = challengesGrid.querySelectorAll('.challenge-card');
                        const queryLower = query.toLowerCase();
                        let visibleCount = 0;
                        
                        cards.forEach(card => {
                            const title = card.querySelector('.challenge-title').textContent;
                            const desc = card.querySelector('.challenge-description').textContent;
                            const matchesQuery = title.toLowerCase().includes(queryLower) || 
                                             desc.toLowerCase().includes(queryLower);
                            
                            if (matchesQuery) {
                                card.style.display = 'flex';
                                visibleCount++;
                            } else {
                                card.style.display = 'none';
                            }
                        });
                        
                        if (visibleCount === 0) {
                            challengesGrid.innerHTML = `<p>No se encontraron desafíos que coincidan con "${query}"</p>`;
                        }
                        
                        return;
                    }
                    
                    throw new Error(`Error ${response.status} obteniendo desafíos`);
                }
                
                // Similar a loadChallengesPaginated, procesar la respuesta...
                // Obtener información de paginación
                challengesTotalItems = parseInt(response.headers.get('X-Total-Count') || '0');
                challengesTotalPages = parseInt(response.headers.get('X-Total-Pages') || '1');
                challengesCurrentPage = parseInt(response.headers.get('X-Current-Page') || '0') + 1;
                
                const responseData = await response.json();
                
                let desafios;
                if (responseData && Array.isArray(responseData)) {
                    desafios = responseData;
                } else if (responseData && typeof responseData === 'object' && Array.isArray(responseData.content)) {
                    desafios = responseData.content;
                    // Si no tenemos totalItems de los headers, usar datos de paginación del objeto
                    if (challengesTotalItems === 0 && responseData.totalElements) {
                        challengesTotalItems = responseData.totalElements;
                        challengesTotalPages = responseData.totalPages || Math.ceil(responseData.totalElements / challengesPageSize);
                        challengesCurrentPage = responseData.number + 1 || 1;
                    }
                } else {
                    console.warn('Formato de respuesta inesperado:', responseData);
                    desafios = [];
                }
                
                // Actualizar controles de paginación
                updateChallengesPaginationControls();
                
                // Cargar participaciones y renderizar como en loadChallengesPaginated
                const participacionesResponse = await fetch(`${API_DESAFIOS_URL}/mis-participaciones`);
                const participacionMap = new Map();
                
                if (participacionesResponse.ok) {
                    const participacionesData = await participacionesResponse.json();
                    const participaciones = Array.isArray(participacionesData) ? 
                        participacionesData : 
                        (participacionesData.content || []);
                    
                    participaciones.forEach(p => {
                        if (p && p.desafioId) {
                            participacionMap.set(p.desafioId, p);
                        }
                    });
                }
                
                // Procesamiento y renderizado de desafíos
                challengesGrid.innerHTML = '';
                
                if (desafios.length === 0) {
                    challengesGrid.innerHTML = `<p>No se encontraron desafíos${query ? ` que coincidan con "${query}"` : ''}.</p>`;
                    return;
                }
                
                // Combinar con participaciones y renderizar
                const desafiosProcesados = desafios.map(desafio => {
                    const desafioConParticipacion = { ...desafio };
                    
                    if (participacionMap.has(desafio.id)) {
                        desafioConParticipacion.participacion = participacionMap.get(desafio.id);
                    }
                    
                    if (!desafioConParticipacion.proyectoNombre && desafioConParticipacion.proyectoId) {
                        desafioConParticipacion.proyectoNombre = `Proyecto ${desafioConParticipacion.proyectoId}`;
                    }
                    
                    return desafioConParticipacion;
                });
                
                // Renderizar desafíos procesados
                desafiosProcesados.forEach((desafio, index) => {
                    setTimeout(() => renderChallengeCard(desafio), 50 * index);
                });
                
            } catch (error) {
                console.error('Error al buscar desafíos:', error);
                challengesGrid.innerHTML = `<p>Error al buscar desafíos: ${error.message}</p>`;
            }
        }

         // Función auxiliar para actualizar el contenido de una tarjeta existente
        function renderProjectCardContent(cardElement, project, isParticipating) {
            // Determinar categoría del proyecto
            let category = isParticipating ? 'participating' : 'available';
            
            // Si el proyecto está expirado, sobrescribir la categoría
            if (project.estado === 'EXPIRADO') {
                category = 'expired';
            }
            
            cardElement.dataset.category = category;
            cardElement.classList.remove('participating', 'available', 'expired');
            cardElement.classList.add(category);

            // Calcula días restantes
            let daysRemaining = 'N/A';
            if (project.fechaExpiracion) {
                const expDate = new Date(project.fechaExpiracion);
                const now = new Date();
                const diffTime = expDate - now;
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                daysRemaining = diffDays > 0 ? `${diffDays} días restantes` : 'Expirado';
            } else {
                daysRemaining = 'Sin fecha límite';
            }
            
            // Personalizar texto de estado según el estado del proyecto
            let statusText = isParticipating ? 'Participando' : 'Disponible';
            if (project.estado === 'EXPIRADO') {
                statusText = 'Expirado';
            } else if (project.estado === 'COMPLETADO') {
                statusText = 'Completado';
            } else if (project.estado === 'CANCELADO') {
                statusText = 'Cancelado';
            } else if (project.estado === 'COMPLETO' && !isParticipating) {
                statusText = 'Completo';
            }
            
            // Ruta de imagen con fallback
            const imagePath = project.imagenUrl ? `/static/Proyectos/${project.imagenUrl}` : defaultImageBase64;
            
            // Actualizar imagen si existe
            const imageElement = cardElement.querySelector('.project-image');
            if (imageElement) {
                imageElement.src = imagePath;
                imageElement.onerror = function() {
                    this.src = defaultImageBase64;
                };
            }
            
            // Actualizar información de participantes
            const participantesInfo = project.participantesActuales !== null ? 
                `${project.participantesActuales}${project.limiteParticipantes ? ' / ' + project.limiteParticipantes : ''}` : 
                'N/A';
            
            // LÓGICA DE BOTONES ACTUALIZADA
            // 1. Si el usuario participa, siempre puede abandonar (incluso en proyectos completos)
            // 2. Si el usuario no participa y el proyecto está completo, muestra "Completo"
            // 3. Si el usuario no participa y el proyecto está activo, muestra "Participar"
            
            let buttonHtml = '';
            if (isParticipating) {
                // Si participa, siempre puede abandonar (sin importar el estado del proyecto)
                buttonHtml = `<button class="leave-project-btn" data-project-id="${project.id}"><i class="fas fa-sign-out-alt"></i> Abandonar Proyecto</button>`;
            } else if (project.estado === 'ACTIVO') {
                // No participa y el proyecto está activo
                if (project.haAlcanzadoLimiteParticipantes || project.estado === 'COMPLETO') {
                    // Proyecto lleno
                    buttonHtml = `<div class="project-status-message">
                        <i class="fas fa-users"></i> Completo
                    </div>`;
                } else {
                    // Proyecto con cupos disponibles
                    buttonHtml = `<button class="join-project-btn" data-project-id="${project.id}"><i class="fas fa-hand-holding-heart"></i> Participar</button>`;
                }
            } else if (project.estado === 'COMPLETO') {
                // No participa y proyecto completo
                buttonHtml = `<div class="project-status-message">
                    <i class="fas fa-users"></i> Completo
                </div>`;
            } else if (project.estado === 'EXPIRADO') {
                // Proyecto expirado
                buttonHtml = `<div class="project-status-message">
                    <i class="fas fa-clock"></i> Proyecto finalizado
                </div>`;
            } else {
                // Para otros estados (CANCELADO, etc.)
                buttonHtml = `<div class="project-status-message">
                    <i class="fas fa-info-circle"></i> Proyecto ${statusText.toLowerCase()}
                </div>`;
            }

            cardElement.querySelector('.project-banner .project-status').textContent = statusText;
            cardElement.querySelector('.project-banner .project-status').className = `project-status ${project.estado.toLowerCase()}`; 
            // Actualizar SVG si es necesario (opcional)
            // cardElement.querySelector('.project-banner svg path').setAttribute('d', ...);
            cardElement.querySelector('.project-content h3').textContent = project.nombre;
            cardElement.querySelector('.project-content p').textContent = project.descripcion || 'Sin descripción.';
            
            // Actualizar los detalles del proyecto
            const detalles = cardElement.querySelector('.project-details');
            if (detalles) {
                detalles.innerHTML = `
                    <span><i class="fas fa-users"></i> ${participantesInfo} voluntarios</span>
                    <span><i class="fas fa-calendar"></i> ${daysRemaining}</span>
                    <span><i class="fas fa-info-circle"></i> Estado: ${project.estado || 'ACTIVO'}</span>
                `;
            }
            
            // Actualizar el botón/div de acción
            const actionContainer = cardElement.querySelector('.project-content');
            // Eliminar botones o mensajes anteriores
            const oldButton = actionContainer.querySelector('.join-project-btn, .leave-project-btn, .project-status-message');
            if (oldButton) {
                oldButton.remove();
            }
            
            // Añadir nuevo botón o mensaje
            actionContainer.insertAdjacentHTML('beforeend', buttonHtml);
            
            // Asignar eventos a los botones
            const joinBtn = actionContainer.querySelector('.join-project-btn');
            if (joinBtn) {
                joinBtn.addEventListener('click', function() {
                    joinProject(project.id);
                });
            }
            
            const leaveBtn = actionContainer.querySelector('.leave-project-btn');
            if (leaveBtn) {
                leaveBtn.addEventListener('click', function() {
                    leaveProject(project.id);
                });
            }
        }

        function renderAllProjects(projects) {
             projectsGrid.innerHTML = ''; // Limpiar antes de renderizar
             if (projects.length === 0) {
                 projectsGrid.innerHTML = '<p>No hay proyectos disponibles en este momento.</p>';
                 return;
             }

             console.log('Renderizando proyectos con participación actual:', currentUserProjects);
             
             projects.forEach(project => {
                 // Determinar si participo verificando varias fuentes
                 let isParticipating = false;
                 
                 // 1. Verificar por ID en el array de currentUserProjects
                 if (currentUserProjects.includes(project.id)) {
                     isParticipating = true;
                 }
                 
                 // 2. Verificar en el propio objeto del proyecto, si tiene esa información
                 if (project.soyParticipante === true) {
                     isParticipating = true;
                 }
                 
                 // 3. Verificar otra posible estructura
                 if (project.participantes && Array.isArray(project.participantes)) {
                     // Si tenemos la lista de participantes en el proyecto y el ID del usuario actual
                     const userId = userData ? userData.id : null;
                     if (userId && project.participantes.some(p => p === userId || p.id === userId || p.usuarioId === userId)) {
                         isParticipating = true;
                     }
                 }
                 
                 console.log(`Proyecto ${project.id} - ${project.nombre}: participo = ${isParticipating}`);
                 renderProjectCard(project, isParticipating);
             });

             // Aplicar filtro inicial (el que esté activo)
             applyFilter();
            // Disparar animación después de renderizar
            animateCardsEntry();
         }
         
         // Variable para almacenar datos del usuario actual
         let userData = null;

         function animateCardsEntry() {
             const cards = document.querySelectorAll('.project-user-card');
             cards.forEach((card, index) => {
                 // Solo animar las visibles inicialmente
                 if (card.style.display !== 'none') { 
                     setTimeout(() => {
                         card.style.opacity = '1';
                         card.style.transform = 'translateY(0)';
                         card.classList.add('show'); // Añadir show si aún se usa para estilos
                     }, 100 * index);
                 }
             });
         }

        // --- FILTRADO --- 
        function applyFilter() {
            const container = activeTab === 'projects' ? projectsFilters : challengesFilters;
            const activeFilterButton = container.querySelector('.filter-btn.active');
            const filter = activeFilterButton ? activeFilterButton.dataset.filter : 'all';
            
            const cards = activeTab === 'projects' 
                ? projectsGrid.querySelectorAll('.project-user-card')
                : challengesGrid.querySelectorAll('.challenge-card');

            cards.forEach(card => {
                card.style.opacity = '0';
                card.style.transform = 'translateY(20px)';
                card.classList.remove('show');
                
                if (filter === 'all' || card.dataset.category === filter) {
                    card.style.display = 'flex';
                    setTimeout(() => {
                        card.style.opacity = '1';
                        card.style.transform = 'translateY(0)';
                        card.classList.add('show');
                    }, 10);
                } else {
                    card.style.display = 'none';
                }
            });
        }

        // --- ACCIONES DE DESAFÍO ---
        async function participateInChallenge(challengeId) {
            try {
                const response = await fetch(`${API_DESAFIOS_URL}/${challengeId}/participar`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    const errorData = await response.text();
                    throw new Error(`Error: ${errorData}`);
                }
                
                // Recargar desafíos para reflejar el cambio
                loadChallengesPaginated();
                
            } catch (error) {
                console.error('Error al participar en el desafío:', error);
                alert(`No se pudo participar en el desafío: ${error.message}`);
            }
        }
        
        async function completeChallenge(challengeId) {
            try {
                // Mostrar un indicador de carga mientras se procesa
                const card = document.querySelector(`.challenge-card[data-challenge-id="${challengeId}"]`);
                const actionButton = card.querySelector('.complete-btn');
                const originalButtonHtml = actionButton.innerHTML;
                actionButton.disabled = true;
                actionButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Procesando...';
                
                // Verificar primero la autenticación
                try {
                    const authResponse = await fetch('/api/usuarios/me', {
                        method: 'GET',
                        credentials: 'include',
                        headers: {
                            'X-Requested-With': 'XMLHttpRequest',
                            'Accept': 'application/json',
                            'Cache-Control': 'no-cache, no-store'
                        }
                    });
                    
                    if (!authResponse.ok) {
                        throw new Error('Tu sesión ha expirado. Por favor, recarga la página e inicia sesión nuevamente.');
                    }
                } catch (authError) {
                    console.error('Error de autenticación:', authError);
                    showNotification('Tu sesión ha expirado. Por favor, recarga la página e inicia sesión nuevamente.', 'error');
                    
                    // Opcional: redirigir al login después de mostrar la notificación
                    setTimeout(() => {
                        window.location.href = '/login?redirectTo=' + encodeURIComponent(window.location.pathname);
                    }, 2000);
                    
                    // Restaurar el botón
                    actionButton.disabled = false;
                    actionButton.innerHTML = originalButtonHtml;
                    return;
                }
                
                // Ejecutar la petición para completar el desafío
                const response = await fetch(`/api/desafios/${challengeId}/completar`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest',
                        'Accept': 'application/json'
                    },
                    credentials: 'include',
                    cache: 'no-cache'
                });
                
                // Restaurar el botón
                actionButton.disabled = false;
                actionButton.innerHTML = originalButtonHtml;
                
                // Procesar la respuesta
                if (!response.ok) {
                    // Manejar errores
                    const contentType = response.headers.get('content-type');
                    let errorMessage = `Error ${response.status}`;
                    
                    if (contentType && contentType.includes('application/json')) {
                        const errorData = await response.json();
                        errorMessage = errorData.error || errorData.mensaje || errorData.message || errorMessage;
                    } else {
                        const errorText = await response.text();
                        
                        if (errorText.includes('<!DOCTYPE') || errorText.includes('<html')) {
                            errorMessage = 'Tu sesión ha expirado. Por favor, recarga la página e inicia sesión nuevamente.';
                            
                            // Redirigir al login después de mostrar la notificación
                            setTimeout(() => {
                                window.location.href = '/login?redirectTo=' + encodeURIComponent(window.location.pathname);
                            }, 2000);
                        } else {
                            errorMessage = errorText || errorMessage;
                        }
                    }
                    
                    throw new Error(errorMessage);
                }
                
                // Manejar respuesta exitosa
                let result;
                const contentType = response.headers.get('content-type');
                
                if (contentType && contentType.includes('application/json')) {
                    result = await response.json();
                } else {
                    result = { mensaje: await response.text() };
                }
                
                // Mostrar mensaje de éxito
                showNotification(result.mensaje || '¡Desafío completado con éxito!', 'success');
                
                // Actualizar la tarjeta antes de recargar
                card.classList.remove('active');
                card.classList.add('completed');
                const progressBar = card.querySelector('.progress');
                if (progressBar) progressBar.style.width = '100%';
                
                // Recargar después de un momento
                setTimeout(() => loadChallengesPaginated(), 1000);
            } catch (error) {
                console.error('Error al completar el desafío:', error);
                showNotification(`No se pudo completar el desafío: ${error.message}`, 'error');
            }
        }

        // --- ACCIONES DE PROYECTO (Unirse/Abandonar) ---
        async function joinProject(projectId) {
            try {
                // Verificar primero si ya estoy participando para evitar errores
                const yaParticipo = await verificarParticipacionEnProyecto(projectId);
                if (yaParticipo) {
                    // Si ya participo, actualizar la interfaz sin intentar unirse de nuevo
                    if (!currentUserProjects.includes(projectId)) {
                        currentUserProjects.push(projectId);
                        saveUserProjectsToLocalStorage();
                    }
                    
                    // Recargar los datos del proyecto
                    const proyectoResponse = await fetch(`${API_PROYECTOS_URL}/${projectId}`);
                    if (proyectoResponse.ok) {
                        const projectData = await proyectoResponse.json();
                        
                        // Actualizar tarjetas
                        const cards = document.querySelectorAll(`.project-user-card[data-project-id="${projectId}"]`);
                        cards.forEach(card => {
                            renderProjectCardContent(card, projectData, true);
                        });
                        
                        // Mostrar mensaje informativo
                        showNotification('info', 'Ya estás participando en este proyecto');
                        return;
                    }
                }
                
                // Primero, verificar si el proyecto está lleno antes de intentar unirse
                try {
                    const projectResponse = await fetch(`${API_PROYECTOS_URL}/${projectId}`);
                    if (projectResponse.ok) {
                        const projectData = await projectResponse.json();
                        
                        // Verificar si está completo o ha alcanzado el límite
                        if (projectData.estado === 'COMPLETO' || 
                            (projectData.participantesActuales !== null && 
                             projectData.limiteParticipantes !== null && 
                             projectData.participantesActuales >= projectData.limiteParticipantes)) {
                            
                            showNotification('warning', 'El proyecto está completo y no admite más participantes');
                            
                            // Actualizar la UI para mostrar el proyecto como completo
                            const cards = document.querySelectorAll(`.project-user-card[data-project-id="${projectId}"]`);
                            cards.forEach(card => {
                                renderProjectCardContent(card, projectData, false);
                            });
                            
                            return;
                        }
                    }
                } catch (error) {
                    console.warn('Error al verificar estado del proyecto:', error);
                    // Continuar de todos modos e intentar unirse
                }
                
                // Si no participo, continuar con la lógica normal
                // Deshabilitar botones durante la acción para evitar clicks múltiples
                const buttons = document.querySelectorAll('.join-project-btn, .leave-project-btn');
                buttons.forEach(btn => btn.disabled = true);
                
                // Enviar la solicitud al servidor
                const rol = 'VOLUNTARIO'; // Rol por defecto
                const response = await fetch(`${API_PROYECTOS_URL}/${projectId}/unirse?rol=${rol}`, {
                    method: 'POST'
                });
                
                // Verificar si la respuesta fue exitosa
                if (!response.ok) {
                    const contentType = response.headers.get("content-type");
                    
                    // Manejar específicamente el caso de proyecto completo (409 Conflict)
                    if (response.status === 409) {
                        // Obtener datos actualizados del proyecto
                        const proyectoResponse = await fetch(`${API_PROYECTOS_URL}/${projectId}`);
                        if (proyectoResponse.ok) {
                            const projectData = await proyectoResponse.json();
                            
                            // Actualizar la UI sin mostrar error
                            const cards = document.querySelectorAll(`.project-user-card[data-project-id="${projectId}"]`);
                            cards.forEach(card => {
                                renderProjectCardContent(card, projectData, false);
                            });
                            
                            // Intentar obtener el mensaje específico del error
                            let errorMsg = 'El proyecto está completo y no admite más participantes';
                            try {
                                const errorText = await response.text();
                                if (errorText && errorText.length > 0) {
                                    // Intentar parsear como JSON primero
                                    try {
                                        const jsonError = JSON.parse(errorText);
                                        if (jsonError.message) {
                                            errorMsg = jsonError.message;
                                        }
                                    } catch (e) {
                                        // Si no es JSON, usar el texto tal cual si no parece HTML
                                        if (!errorText.includes('<!DOCTYPE') && !errorText.includes('<html')) {
                                            errorMsg = errorText;
                                        }
                                    }
                                }
                            } catch (e) {
                                // Si hay error al leer la respuesta, mantener el mensaje por defecto
                                console.warn('Error al leer respuesta de error:', e);
                            }
                            
                            showNotification('warning', errorMsg);
                            return;
                        } else {
                            throw new Error('El proyecto está completo o no admite más participantes');
                        }
                    }
                    
                    // Para otros errores, proceder normalmente
                    if (contentType && contentType.indexOf("application/json") !== -1) {
                        // Si el servidor responde con JSON, manejar el error como JSON
                        const error = await response.json();
                        throw new Error(error.message || 'Error al unirse al proyecto');
                    } else {
                        // Si el servidor responde con texto, manejar el error como texto
                        const errorText = await response.text();
                        throw new Error(errorText || `Error ${response.status}: ${response.statusText}`);
                    }
                }
                
                // Intentar procesar la respuesta como JSON o como texto
                let mensaje;
                const contentType = response.headers.get("content-type");
                if (contentType && contentType.indexOf("application/json") !== -1) {
                    const data = await response.json();
                    mensaje = data.mensaje || 'Te has unido al proyecto exitosamente';
                } else {
                    mensaje = await response.text();
                }
                
                // Actualizar estado local
                if (!currentUserProjects.includes(projectId)) {
                    currentUserProjects.push(projectId);
                    // Guardar en localStorage
                    saveUserProjectsToLocalStorage();
                }
                
                // Re-obtener los datos actualizados del proyecto
                const proyectoResponse = await fetch(`${API_PROYECTOS_URL}/${projectId}`);
                if (!proyectoResponse.ok) {
                    throw new Error('Error al obtener datos actualizados del proyecto');
                }
                
                const projectData = await proyectoResponse.json();
                
                // Actualizar todas las tarjetas de este proyecto
                const cards = document.querySelectorAll(`.project-user-card[data-project-id="${projectId}"]`);
                cards.forEach(card => {
                    renderProjectCardContent(card, projectData, true); // Ahora ESTOY participando
                });
                
                // También actualizar el modal si está abierto
                const projectModal = document.getElementById('projectModal');
                if (projectModal && projectModal.classList.contains('show') && 
                    projectModal.dataset.projectId === projectId) {
                    updateProjectActions(projectData);
                }
                
                // Mostrar mensaje de éxito
                showNotification('success', mensaje);
                
                // Reaplicar filtro actual
                applyFilter();
                
            } catch (error) {
                console.error('Error al unirse al proyecto:', error);
                showNotification('error', error.message || 'Error al unirse al proyecto');
            } finally {
                // Re-habilitar botones
                const buttons = document.querySelectorAll('.join-project-btn, .leave-project-btn');
                buttons.forEach(btn => btn.disabled = false);
            }
        }
        
        // Función auxiliar para mostrar mensajes
        function showMessage(type, title, message) {
            // Si tienes una librería de notificaciones, úsala aquí
            // Por ejemplo, sweetalert2:
            if (window.Swal) {
                Swal.fire({
                    icon: type,
                    title: title,
                    text: message
                });
            } else {
                // Fallback a alert nativo
                alert(message);
            }
        }
        
        // Función para mostrar notificaciones
        function showNotification(type, message) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `
                <span>${message}</span>
                <button class="close-notification">&times;</button>
            `;
            
            document.body.appendChild(notification);
            
            // Mostrar notificación
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);
            
            // Ocultar después de 3 segundos
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
            
            // Configurar botón para cerrar
            notification.querySelector('.close-notification').addEventListener('click', () => {
                notification.classList.remove('show');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            });
        }
        
        // Función para actualizar la UI cuando el usuario se une/abandona un proyecto
        function updateProjectParticipation(projectId, isParticipating) {
            // Actualizar la tarjeta del proyecto en la vista principal
            const projectCard = document.querySelector(`.project-user-card[data-project-id="${projectId}"]`);
            if (projectCard) {
                const project = window.projectsData.find(p => p.id === projectId);
                if (project) {
                    renderProjectCardContent(projectCard, project, isParticipating);
                }
            }
            
            // Actualizar los filtros si es necesario
            applyFilter();
        }

         async function leaveProject(projectId) {
            if (!confirm('¿Seguro que quieres abandonar este proyecto?')) return;

            try {
                // Antes de intentar abandonar, verificar si realmente estamos participando
                const participando = await verificarParticipacionEnProyecto(projectId);
                if (!participando) {
                    // Si no estamos participando según el servidor, solo actualizar la UI local
                    console.log(`No estás participando en el proyecto ${projectId} según el servidor, actualizando UI local`);
                    
                    // Eliminar de la lista local de proyectos
                    currentUserProjects = currentUserProjects.filter(id => id !== projectId);
                    saveUserProjectsToLocalStorage();
                    
                    // Recargar datos del proyecto
                    const proyectoResponse = await fetch(`${API_PROYECTOS_URL}/${projectId}`);
                    if (proyectoResponse.ok) {
                        const projectData = await proyectoResponse.json();
                        
                        // Actualizar tarjetas
                        const cards = document.querySelectorAll(`.project-user-card[data-project-id="${projectId}"]`);
                        cards.forEach(card => {
                            renderProjectCardContent(card, projectData, false);
                        });
                        
                        // Mostrar mensaje
                        showNotification('info', 'Ya no participas en este proyecto');
                        
                        // Reaplicar filtro
                        applyFilter();
                        return;
                    }
                }
                
                // Si participamos, continuar con la lógica normal
                const response = await fetch(`${API_PROYECTOS_URL}/${projectId}/abandonar`, {
                    method: 'DELETE',
                    headers: { 
                        // Headers de autenticación si son necesarios 
                    }
                });

                // Manejar los casos específicos de error
                if (!response.ok) {
                    // Para error 404 (no encontrado) o 409 (conflicto por no participar)
                    if (response.status === 404 || response.status === 409) {
                        console.log(`Error ${response.status} al abandonar el proyecto ${projectId} - actualizando estado local`);
                        
                        // Actualizar el estado local aunque el servidor reportó error
                        currentUserProjects = currentUserProjects.filter(id => id !== projectId);
                        saveUserProjectsToLocalStorage();
                        
                        // Obtener datos actualizados del proyecto
                        const proyectoResponse = await fetch(`${API_PROYECTOS_URL}/${projectId}`);
                        if (proyectoResponse.ok) {
                            const projectData = await proyectoResponse.json();
                            
                            // Actualizar todas las tarjetas de este proyecto
                            const cards = document.querySelectorAll(`.project-user-card[data-project-id="${projectId}"]`);
                            cards.forEach(card => {
                                renderProjectCardContent(card, projectData, false);
                            });
                            
                            // Mostrar notificación informativa
                            showNotification('info', 'Ya no estás participando en este proyecto');
                            
                            // Reaplicar filtro actual
                            applyFilter();
                            return;
                        } else {
                            throw new Error(`No se pudo obtener información actualizada del proyecto`);
                        }
                    } else {
                        // Para otros errores, intentar extraer mensaje
                        const contentType = response.headers.get("content-type");
                        let errorMsg = `Error ${response.status} al abandonar el proyecto`;
                        
                        try {
                            const errorText = await response.text();
                            
                            // Si es JSON, intentar extraer mensaje
                            if (contentType && contentType.indexOf("application/json") !== -1) {
                                try {
                                    const errorData = JSON.parse(errorText);
                                    errorMsg = errorData.message || errorData.error || errorMsg;
                                } catch (e) {
                                    // Si falla el parse de JSON, usar el texto tal cual
                                    errorMsg = errorText;
                                }
                            } else if (errorText && !errorText.includes('<!DOCTYPE') && !errorText.includes('<html')) {
                                // Si no es HTML, usar el texto tal cual
                                errorMsg = errorText;
                            }
                        } catch (e) {
                            console.warn("Error al leer respuesta de error:", e);
                        }
                        
                        throw new Error(errorMsg);
                    }
                }

                // Actualizar UI
                currentUserProjects = currentUserProjects.filter(id => id !== projectId); // Actualizar estado local
                // Guardar en localStorage
                saveUserProjectsToLocalStorage();
                
                // Re-obtener los datos actualizados del proyecto para reflejar el cambio en participantesActuales
                const proyectoResponse = await fetch(`${API_PROYECTOS_URL}/${projectId}`);
                if (!proyectoResponse.ok) {
                    throw new Error('Error al obtener datos actualizados del proyecto');
                }
                
                const projectData = await proyectoResponse.json();
                
                // Actualizar todas las tarjetas de este proyecto
                const cards = document.querySelectorAll(`.project-user-card[data-project-id="${projectId}"]`);
                cards.forEach(card => {
                    renderProjectCardContent(card, projectData, false); // Ahora NO estoy participando
                });
                
                // También actualizar el modal si está abierto
                const projectModal = document.getElementById('projectModal');
                if (projectModal && projectModal.classList.contains('show') && 
                    projectModal.dataset.projectId === projectId) {
                    
                    // Verificar si la función updateProjectActions y el container existen
                    const actionsContainer = document.getElementById('modal-project-actions');
                    if (typeof updateProjectActions === 'function' && actionsContainer) {
                        updateProjectActions(projectData);
                    }
                }
                
                // Mostrar notificación de éxito
                showNotification('success', 'Has abandonado el proyecto exitosamente');
                
                // Reaplicar filtro actual
                applyFilter();
            } catch (error) {
                console.error('Error al abandonar el proyecto:', error);
                showNotification(`No se pudo abandonar el proyecto: ${error.message}`, 'error');
            }
        }

        // --- BÚSQUEDA ---
        async function searchItems() {
            const query = document.getElementById('userSearchInput').value;
            
            if (activeTab === 'projects') {
                await searchProjectsPaginated(query);
            } else {
                await searchChallengesPaginated(query);
            }
        }
        
        async function searchProjectsPaginated(query, page = 1) {
            projectsGrid.innerHTML = '<p>Buscando...</p>';

            try {
                let url;
                if (query) {
                    url = `${API_PROYECTOS_URL}/buscar?nombre=${encodeURIComponent(query)}&page=${page-1}&size=${pageSize}`;
                } else {
                    url = `${API_PROYECTOS_URL}?page=${page-1}&size=${pageSize}`;
                }

                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Error HTTP: ${response.status}`);
                }
                
                // Obtener información de paginación
                totalItems = parseInt(response.headers.get('X-Total-Count') || '0');
                totalPages = parseInt(response.headers.get('X-Total-Pages') || '1');
                currentPage = parseInt(response.headers.get('X-Current-Page') || '0') + 1;
                
                const responseData = await response.json();
                
                // Actualizar controles de paginación
                updatePaginationControls();
                
                // Determinar si la respuesta es un objeto paginado o un array directo
                let projects;
                if (responseData && Array.isArray(responseData)) {
                    projects = responseData;
                } else if (responseData && typeof responseData === 'object' && Array.isArray(responseData.content)) {
                    projects = responseData.content;
                    // Si no tenemos totalItems de los headers, usar datos de paginación del objeto
                    if (totalItems === 0 && responseData.totalElements) {
                        totalItems = responseData.totalElements;
                        totalPages = responseData.totalPages || Math.ceil(responseData.totalElements / pageSize);
                        currentPage = responseData.number + 1 || 1;
                        updatePaginationControls();
                    }
                } else {
                    console.warn('Formato de respuesta inesperado:', responseData);
                    projects = [];
                }
                
                renderAllProjects(projects);
            } catch (error) {
                console.error('Error al buscar proyectos:', error);
                projectsGrid.innerHTML = '<p>Error al realizar la búsqueda. Intente de nuevo.</p>';
            }
        }
        
        async function searchChallengesPaginated(query, page = 1) {
            // Implementación similar a loadChallengesPaginated pero con filtro de búsqueda
            challengesGrid.innerHTML = '<p>Buscando...</p>';
            
            try {
                let url;
                if (query) {
                    url = `${API_DESAFIOS_URL}/buscar?nombre=${encodeURIComponent(query)}&page=${page-1}&size=${challengesPageSize}`;
                } else {
                    url = `${API_DESAFIOS_URL}/paginados?page=${page-1}&size=${challengesPageSize}`;
                }
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    // Si falla el endpoint específico de búsqueda, cargar todos y filtrar en cliente
                    if (query) {
                        await loadChallengesPaginated(page);
                        
                        // Filtrar los desafíos mostrados según el query
                        const cards = challengesGrid.querySelectorAll('.challenge-card');
                        const queryLower = query.toLowerCase();
                        let visibleCount = 0;
                        
                        cards.forEach(card => {
                            const title = card.querySelector('.challenge-title').textContent;
                            const desc = card.querySelector('.challenge-description').textContent;
                            const matchesQuery = title.toLowerCase().includes(queryLower) || 
                                             desc.toLowerCase().includes(queryLower);
                            
                            if (matchesQuery) {
                                card.style.display = 'flex';
                                visibleCount++;
                            } else {
                                card.style.display = 'none';
                            }
                        });
                        
                        if (visibleCount === 0) {
                            challengesGrid.innerHTML = `<p>No se encontraron desafíos que coincidan con "${query}"</p>`;
                        }
                        
                        return;
                    }
                    
                    throw new Error(`Error ${response.status} obteniendo desafíos`);
                }
                
                // Similar a loadChallengesPaginated, procesar la respuesta...
                // Obtener información de paginación
                challengesTotalItems = parseInt(response.headers.get('X-Total-Count') || '0');
                challengesTotalPages = parseInt(response.headers.get('X-Total-Pages') || '1');
                challengesCurrentPage = parseInt(response.headers.get('X-Current-Page') || '0') + 1;
                
                const responseData = await response.json();
                
                let desafios;
                if (responseData && Array.isArray(responseData)) {
                    desafios = responseData;
                } else if (responseData && typeof responseData === 'object' && Array.isArray(responseData.content)) {
                    desafios = responseData.content;
                    // Si no tenemos totalItems de los headers, usar datos de paginación del objeto
                    if (challengesTotalItems === 0 && responseData.totalElements) {
                        challengesTotalItems = responseData.totalElements;
                        challengesTotalPages = responseData.totalPages || Math.ceil(responseData.totalElements / challengesPageSize);
                        challengesCurrentPage = responseData.number + 1 || 1;
                    }
                } else {
                    console.warn('Formato de respuesta inesperado:', responseData);
                    desafios = [];
                }
                
                // Actualizar controles de paginación
                updateChallengesPaginationControls();
                
                // Cargar participaciones y renderizar como en loadChallengesPaginated
                const participacionesResponse = await fetch(`${API_DESAFIOS_URL}/mis-participaciones`);
                const participacionMap = new Map();
                
                if (participacionesResponse.ok) {
                    const participacionesData = await participacionesResponse.json();
                    const participaciones = Array.isArray(participacionesData) ? 
                        participacionesData : 
                        (participacionesData.content || []);
                    
                    participaciones.forEach(p => {
                        if (p && p.desafioId) {
                            participacionMap.set(p.desafioId, p);
                        }
                    });
                }
                
                // Procesamiento y renderizado de desafíos
                challengesGrid.innerHTML = '';
                
                if (desafios.length === 0) {
                    challengesGrid.innerHTML = `<p>No se encontraron desafíos${query ? ` que coincidan con "${query}"` : ''}.</p>`;
                    return;
                }
                
                // Combinar con participaciones y renderizar
                const desafiosProcesados = desafios.map(desafio => {
                    const desafioConParticipacion = { ...desafio };
                    
                    if (participacionMap.has(desafio.id)) {
                        desafioConParticipacion.participacion = participacionMap.get(desafio.id);
                    }
                    
                    if (!desafioConParticipacion.proyectoNombre && desafioConParticipacion.proyectoId) {
                        desafioConParticipacion.proyectoNombre = `Proyecto ${desafioConParticipacion.proyectoId}`;
                    }
                    
                    return desafioConParticipacion;
                });
                
                // Renderizar desafíos procesados
                desafiosProcesados.forEach((desafio, index) => {
                    setTimeout(() => renderChallengeCard(desafio), 50 * index);
                });
                
            } catch (error) {
                console.error('Error al buscar desafíos:', error);
                challengesGrid.innerHTML = `<p>Error al buscar desafíos: ${error.message}</p>`;
            }
        }

         // Función auxiliar para actualizar el contenido de una tarjeta existente
        function renderProjectCardContent(cardElement, project, isParticipating) {
            // Determinar categoría del proyecto
            let category = isParticipating ? 'participating' : 'available';
            
            // Si el proyecto está expirado, sobrescribir la categoría
            if (project.estado === 'EXPIRADO') {
                category = 'expired';
            }
            
            cardElement.dataset.category = category;
            cardElement.classList.remove('participating', 'available', 'expired');
            cardElement.classList.add(category);

            // Calcula días restantes
            let daysRemaining = 'N/A';
            if (project.fechaExpiracion) {
                const expDate = new Date(project.fechaExpiracion);
                const now = new Date();
                const diffTime = expDate - now;
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                daysRemaining = diffDays > 0 ? `${diffDays} días restantes` : 'Expirado';
            } else {
                daysRemaining = 'Sin fecha límite';
            }
            
            // Personalizar texto de estado según el estado del proyecto
            let statusText = isParticipating ? 'Participando' : 'Disponible';
            if (project.estado === 'EXPIRADO') {
                statusText = 'Expirado';
            } else if (project.estado === 'COMPLETADO') {
                statusText = 'Completado';
            } else if (project.estado === 'CANCELADO') {
                statusText = 'Cancelado';
            } else if (project.estado === 'COMPLETO' && !isParticipating) {
                statusText = 'Completo';
            }
            
            // Ruta de imagen con fallback
            const imagePath = project.imagenUrl ? `/static/Proyectos/${project.imagenUrl}` : defaultImageBase64;
            
            // Actualizar imagen si existe
            const imageElement = cardElement.querySelector('.project-image');
            if (imageElement) {
                imageElement.src = imagePath;
                imageElement.onerror = function() {
                    this.src = defaultImageBase64;
                };
            }
            
            // Actualizar información de participantes
            const participantesInfo = project.participantesActuales !== null ? 
                `${project.participantesActuales}${project.limiteParticipantes ? ' / ' + project.limiteParticipantes : ''}` : 
                'N/A';
            
            // LÓGICA DE BOTONES ACTUALIZADA
            // 1. Si el usuario participa, siempre puede abandonar (incluso en proyectos completos)
            // 2. Si el usuario no participa y el proyecto está completo, muestra "Completo"
            // 3. Si el usuario no participa y el proyecto está activo, muestra "Participar"
            
            let buttonHtml = '';
            if (isParticipating) {
                // Si participa, siempre puede abandonar (sin importar el estado del proyecto)
                buttonHtml = `<button class="leave-project-btn" data-project-id="${project.id}"><i class="fas fa-sign-out-alt"></i> Abandonar Proyecto</button>`;
            } else if (project.estado === 'ACTIVO') {
                // No participa y el proyecto está activo
                if (project.haAlcanzadoLimiteParticipantes || project.estado === 'COMPLETO') {
                    // Proyecto lleno
                    buttonHtml = `<div class="project-status-message">
                        <i class="fas fa-users"></i> Completo
                    </div>`;
                } else {
                    // Proyecto con cupos disponibles
                    buttonHtml = `<button class="join-project-btn" data-project-id="${project.id}"><i class="fas fa-hand-holding-heart"></i> Participar</button>`;
                }
            } else if (project.estado === 'COMPLETO') {
                // No participa y proyecto completo
                buttonHtml = `<div class="project-status-message">
                    <i class="fas fa-users"></i> Completo
                </div>`;
            } else if (project.estado === 'EXPIRADO') {
                // Proyecto expirado
                buttonHtml = `<div class="project-status-message">
                    <i class="fas fa-clock"></i> Proyecto finalizado
                </div>`;
            } else {
                // Para otros estados (CANCELADO, etc.)
                buttonHtml = `<div class="project-status-message">
                    <i class="fas fa-info-circle"></i> Proyecto ${statusText.toLowerCase()}
                </div>`;
            }

            cardElement.querySelector('.project-banner .project-status').textContent = statusText;
            cardElement.querySelector('.project-banner .project-status').className = `project-status ${project.estado.toLowerCase()}`; 
            // Actualizar SVG si es necesario (opcional)
            // cardElement.querySelector('.project-banner svg path').setAttribute('d', ...);
            cardElement.querySelector('.project-content h3').textContent = project.nombre;
            cardElement.querySelector('.project-content p').textContent = project.descripcion || 'Sin descripción.';
            
            // Actualizar los detalles del proyecto
            const detalles = cardElement.querySelector('.project-details');
            if (detalles) {
                detalles.innerHTML = `
                    <span><i class="fas fa-users"></i> ${participantesInfo} voluntarios</span>
                    <span><i class="fas fa-calendar"></i> ${daysRemaining}</span>
                    <span><i class="fas fa-info-circle"></i> Estado: ${project.estado || 'ACTIVO'}</span>
                `;
            }
            
            // Actualizar el botón/div de acción
            const actionContainer = cardElement.querySelector('.project-content');
            // Eliminar botones o mensajes anteriores
            const oldButton = actionContainer.querySelector('.join-project-btn, .leave-project-btn, .project-status-message');
            if (oldButton) {
                oldButton.remove();
            }
            
            // Añadir nuevo botón o mensaje
            actionContainer.insertAdjacentHTML('beforeend', buttonHtml);
            
            // Asignar eventos a los botones
            const joinBtn = actionContainer.querySelector('.join-project-btn');
            if (joinBtn) {
                joinBtn.addEventListener('click', function() {
                    joinProject(project.id);
                });
            }
            
            const leaveBtn = actionContainer.querySelector('.leave-project-btn');
            if (leaveBtn) {
                leaveBtn.addEventListener('click', function() {
                    leaveProject(project.id);
                });
            }
        }

        // --- INICIALIZACIÓN Y EVENT LISTENERS ---
        document.addEventListener('DOMContentLoaded', () => {
            // Inicializar variable que almacenará proyectos en los que participo
            window.currentUserProjects = [];
            
            // Intentar cargar proyectos desde localStorage primero
            const loadedFromStorage = loadUserProjectsFromLocalStorage();
            
            // Configurar event listeners para paginación de proyectos
            prevPageButton.addEventListener('click', () => {
                if (currentPage > 1) {
                    loadDataAndRender(currentPage - 1);
                }
            });
            
            nextPageButton.addEventListener('click', () => {
                if (currentPage < totalPages) {
                    loadDataAndRender(currentPage + 1);
                }
            });
            
            // Configurar event listeners para paginación de desafíos
            challengesPrevPageButton.addEventListener('click', () => {
                if (challengesCurrentPage > 1) {
                    loadChallengesPaginated(challengesCurrentPage - 1);
                }
            });
            
            challengesNextPageButton.addEventListener('click', () => {
                if (challengesCurrentPage < challengesTotalPages) {
                    loadChallengesPaginated(challengesCurrentPage + 1);
                }
            });
            
            // Si se cargaron proyectos desde localStorage, renderizar de inmediato
            if (loadedFromStorage) {
                console.log('Usando proyectos de localStorage:', currentUserProjects);
                loadDataAndRender();
            }
            
            // Event listeners para pestañas
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    switchTab(button.dataset.tab);
                });
            });
            
            // Event listeners para filtros
            document.querySelectorAll('.filter-section').forEach(section => {
                section.querySelectorAll('.filter-btn').forEach(button => {
                    button.addEventListener('click', () => {
                        section.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                        button.classList.add('active');
                        applyFilter();
                    });
                });
            });
            
            // Listener para búsqueda
            const searchButton = document.querySelector('.search-btn');
            if (searchButton) {
                searchButton.addEventListener('click', searchItems);
            }
            
            // Permitir búsqueda al presionar Enter
            const searchInput = document.getElementById('userSearchInput');
            if (searchInput) {
                searchInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        searchItems();
                    }
                });
            }
            
            // Cargar primera página de proyectos
            loadDataAndRender();
        });
    </script>

    <!-- Modal para Detalles del Proyecto -->
    <div class="modal-overlay" id="projectDetailModal">
        <div class="modal-container">
            <div class="modal-header">
                <h2 id="modal-project-title">Detalles del Proyecto</h2>
                <button class="modal-close-btn" onclick="closeModal('projectDetailModal')">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-content">
                <div class="project-detail-info">
                    <div class="project-detail-header">
                        <div class="project-detail-banner">
                            <div class="project-detail-status" id="modal-project-status">Activo</div>
                            <!-- *** CORRECCIÓN RUTA IMAGEN *** -->
                            <img id="modal-project-image" src="/static/img/default-project.jpg" alt="Imagen del proyecto" onerror="this.onerror=null; this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjYwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9IiNlYWVhZWEiLz48dGV4dCB4PSI1MCUiIHk9IjUwJSIgZG9taW5hbnQtYmFzZWxpbmU9Im1pZGRsZSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEyIiBmaWxsPSIjYWFhIj5JbWFnZW48L3RleHQ+PC9zdmc+'"> 
                        </div>
                        <div class="project-detail-meta">
                            <p id="modal-project-description">Descripción del proyecto...</p>
                            <div class="project-detail-dates">
                                <span><i class="fas fa-calendar-plus"></i> Creado: <span id="modal-project-created">01/01/2023</span></span>
                                <span><i class="fas fa-calendar-times"></i> Finaliza: <span id="modal-project-expires">01/12/2023</span></span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="project-detail-stats">
                        <div class="stat-box">
                            <i class="fas fa-users"></i>
                            <span class="stat-value" id="modal-project-participants">0</span>
                            <span class="stat-label">Participantes</span>
                        </div>
                        <div class="stat-box">
                            <i class="fas fa-trophy"></i>
                            <span class="stat-value" id="modal-project-challenges">0</span>
                            <span class="stat-label">Desafíos</span>
                        </div>
                        <div class="stat-box">
                            <i class="fas fa-comments"></i>
                            <span class="stat-value" id="modal-project-forums">0</span>
                            <span class="stat-label">Foros</span>
                        </div>
                    </div>
                    
                    <div class="project-detail-actions" id="modal-project-actions">
                        <!-- Botones de acción: Unirse, Ver foro, etc. -->
                    </div>
                </div>
                
                <div class="project-detail-tabs">
                    <button class="detail-tab-btn active" data-tab="participants" onclick="switchDetailTab('participants')">
                        <i class="fas fa-users"></i> Participantes
                    </button>
                    <button class="detail-tab-btn" data-tab="challenges" onclick="switchDetailTab('challenges')">
                        <i class="fas fa-trophy"></i> Desafíos
                    </button>
                    <button class="detail-tab-btn" data-tab="admin" onclick="switchDetailTab('admin')">
                        <i class="fas fa-cog"></i> Administración
                    </button>
                </div>
                
                <div class="project-detail-tab-content">
                    <!-- Panel de Participantes -->
                    <div class="detail-tab-panel active" id="participants-panel">
                        <h3>Participantes del Proyecto</h3>
                        <div class="participants-list" id="modal-participants-list">
                            <!-- Aquí se cargarán los participantes -->
                            <p class="loading-message">Cargando participantes...</p>
                        </div>
                    </div>
                    
                    <!-- Panel de Desafíos -->
                    <div class="detail-tab-panel" id="challenges-panel">
                        <h3>Desafíos del Proyecto</h3>
                        <div class="challenges-list" id="modal-challenges-list">
                            <!-- Aquí se cargarán los desafíos -->
                            <p class="loading-message">Cargando desafíos...</p>
                        </div>
                    </div>
                    
                    <!-- Panel de Administración -->
                    <div class="detail-tab-panel" id="admin-panel">
                        <h3>Administración del Proyecto</h3>
                        <div class="admin-controls">
                            <button class="admin-btn edit-btn" id="edit-project-btn" type="button">
                                <i class="fas fa-edit"></i> Editar Proyecto
                            </button>
                            <button class="admin-btn danger-btn" id="delete-project-btn" type="button">
                                <i class="fas fa-trash-alt"></i> Eliminar Proyecto
                            </button>
                        </div>
                        <div class="edit-project-form" id="edit-project-form" style="display:none;">
                            <h4>Editar Información del Proyecto</h4>
                            <form id="project-edit-form">
                                <input type="hidden" id="edit-project-id">
                                <div class="form-group">
                                    <label for="edit-project-name">Nombre:</label>
                                    <input type="text" id="edit-project-name" class="form-input" required>
                                </div>
                                <div class="form-group">
                                    <label for="edit-project-description">Descripción:</label>
                                    <textarea id="edit-project-description" class="form-input" rows="4" required></textarea>
                                </div>
                                <div class="form-group">
                                    <label for="edit-project-expiration">Fecha de Expiración:</label>
                                    <input type="datetime-local" id="edit-project-expiration" class="form-input">
                                </div>
                                <div class="form-group">
                                    <label for="edit-project-status">Estado:</label>
                                    <select id="edit-project-status" class="form-input">
                                        <option value="ACTIVO">Activo</option>
                                        <option value="COMPLETADO">Completado</option>
                                        <option value="EXPIRADO">Expirado</option>
                                        <option value="CANCELADO">Cancelado</option>
                                    </select>
                                </div>
                                <div class="form-actions">
                                    <button type="button" class="cancel-btn" onclick="toggleEditForm(false)">Cancelar</button>
                                    <button type="submit" class="save-btn">Guardar Cambios</button>
                                </div>
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Funciones para modal de detalles de proyecto
        function openProjectDetails(projectId) {
            // Verificar si el modal existe
            const detailModal = document.getElementById('projectDetailModal');
            if (!detailModal) {
                console.warn('Modal de detalles no encontrado. No se puede abrir.');
                showNotification('info', 'Vista de detalles no disponible');
                return;
            }
            
            // Verificar si los elementos necesarios existen
            const titleElement = document.getElementById('modal-project-title');
            const descriptionElement = document.getElementById('modal-project-description');
            const participantsListElement = document.getElementById('modal-participants-list');
            const challengesListElement = document.getElementById('modal-challenges-list');
            
            if (!titleElement || !descriptionElement || !participantsListElement || !challengesListElement) {
                console.warn('Faltan elementos en el modal de detalles del proyecto');
                showNotification('info', 'Vista de detalles no disponible');
                return;
            }
            
            // Si todo existe, continuar con la lógica normal
            // Limpiar datos anteriores
            titleElement.textContent = 'Cargando...';
            descriptionElement.textContent = 'Cargando información del proyecto...';
            participantsListElement.innerHTML = '<p class="loading-message">Cargando participantes...</p>';
            challengesListElement.innerHTML = '<p class="loading-message">Cargando desafíos...</p>';
            
            // Mostrar modal
            detailModal.style.display = 'flex';
            
            // Restablecer la visibilidad del formulario de edición (ocultarlo)
            const editForm = document.getElementById('edit-project-form');
            if (editForm) {
                editForm.style.display = 'none';
            }
            
            // Verificar permisos de usuario para mostrar/ocultar la pestaña de administración
            fetch('/api/usuarios/me')
                .then(response => response.json())
                .then(userData => {
                    const isAdmin = userData.rol === 'ADMIN';
                    const adminTabBtn = document.querySelector('.detail-tab-btn[data-tab="admin"]');
                    const adminPanel = document.getElementById('admin-panel');
                    
                    if (adminTabBtn) {
                        adminTabBtn.style.display = isAdmin ? 'block' : 'none';
                    }
                    if (adminPanel) {
                        adminPanel.style.display = isAdmin ? 'block' : 'none';
                    }
                })
                .catch(error => {
                    console.error('Error al verificar permisos:', error);
                });
            
            // Cargar datos del proyecto
            fetch(`/api/proyectos/${projectId}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Error ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(proyecto => {
                    // Verificar cada elemento antes de usarlo
                    const elements = {
                        'modal-project-title': document.getElementById('modal-project-title'),
                        'modal-project-description': document.getElementById('modal-project-description'),
                        'modal-project-status': document.getElementById('modal-project-status'),
                        'modal-project-created': document.getElementById('modal-project-created'),
                        'modal-project-expires': document.getElementById('modal-project-expires'),
                        'edit-project-id': document.getElementById('edit-project-id'),
                        'edit-project-name': document.getElementById('edit-project-name'),
                        'edit-project-description': document.getElementById('edit-project-description'),
                        'edit-project-status': document.getElementById('edit-project-status'),
                        'edit-project-expiration': document.getElementById('edit-project-expiration')
                    };
                    
                    // Actualizar información en el modal (si existen los elementos)
                    if (elements['modal-project-title']) elements['modal-project-title'].textContent = proyecto.nombre;
                    if (elements['modal-project-description']) elements['modal-project-description'].textContent = proyecto.descripcion || 'Sin descripción';
                    
                    if (elements['modal-project-status']) {
                        elements['modal-project-status'].textContent = getStatusName(proyecto.estado);
                        elements['modal-project-status'].className = `project-detail-status ${proyecto.estado.toLowerCase()}`;
                    }
                    
                    // Fechas
                    const fechaCreacion = proyecto.fechaCreacion ? new Date(proyecto.fechaCreacion).toLocaleDateString() : 'N/A';
                    if (elements['modal-project-created']) elements['modal-project-created'].textContent = fechaCreacion;
                    
                    const fechaExpiracion = proyecto.fechaExpiracion ? new Date(proyecto.fechaExpiracion).toLocaleDateString() : 'Sin fecha límite';
                    if (elements['modal-project-expires']) elements['modal-project-expires'].textContent = fechaExpiracion;
                    
                    // Botones de acción
                    const actionsContainer = document.getElementById('modal-project-actions');
                    if (actionsContainer && typeof updateProjectActions === 'function') {
                        updateProjectActions(proyecto);
                    }
                    
                    // Para el formulario de edición
                    if (elements['edit-project-id']) elements['edit-project-id'].value = proyecto.id;
                    if (elements['edit-project-name']) elements['edit-project-name'].value = proyecto.nombre;
                    if (elements['edit-project-description']) elements['edit-project-description'].value = proyecto.descripcion || '';
                    if (elements['edit-project-status']) elements['edit-project-status'].value = proyecto.estado;
                    
                    if (proyecto.fechaExpiracion && elements['edit-project-expiration']) {
                        // Formatear fecha para datetime-local input
                        const expDate = new Date(proyecto.fechaExpiracion);
                        const formattedDate = expDate.toISOString().slice(0, 16);
                        elements['edit-project-expiration'].value = formattedDate;
                    } else if (elements['edit-project-expiration']) {
                        elements['edit-project-expiration'].value = '';
                    }
                    
                    // Cargar participantes
                    loadProjectParticipants(projectId);
                    
                    // Cargar desafíos
                    loadProjectChallenges(projectId);
                })
                .catch(error => {
                    console.error('Error al cargar detalles del proyecto:', error);
                    document.getElementById('modal-project-title').textContent = 'Error';
                    document.getElementById('modal-project-description').textContent = `No se pudo cargar la información del proyecto: ${error.message}`;
                });
        }
        
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }
        
        function switchDetailTab(tabName) {
            // Desactivar todas las pestañas y paneles
            document.querySelectorAll('.detail-tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelectorAll('.detail-tab-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            
            // Activar la pestaña seleccionada
            document.querySelector(`.detail-tab-btn[data-tab="${tabName}"]`).classList.add('active');
            document.getElementById(`${tabName}-panel`).classList.add('active');
        }
        
        function loadProjectParticipants(projectId) {
            const participantsList = document.getElementById('modal-participants-list');
            const participantsCount = document.getElementById('modal-project-participants');
            
            if (!participantsList) {
                console.warn('No se encontró la lista de participantes');
                return;
            }
            
            fetch(`/api/proyectos/${projectId}/participantes`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Error ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(participantes => {
                    // Actualizar contador
                    if (participantsCount) {
                        participantsCount.textContent = participantes.length;
                    }
                    
                    // Mostrar participantes
                    if (participantes.length === 0) {
                        participantsList.innerHTML = '<p>No hay participantes en este proyecto.</p>';
                    } else {
                        participantsList.innerHTML = '';
                        participantes.forEach(participante => {
                            const avatarUrl = participante.imagenPerfil || '/img/default-avatar.jpg';
                            
                            const card = document.createElement('div');
                            card.className = 'participant-card';
                            card.innerHTML = `
                                <img src="${avatarUrl}" alt="${participante.nombre}" class="participant-avatar">
                                <div class="participant-name">${participante.nombre}</div>
                                <div class="participant-role">${participante.rol}</div>
                            `;
                            participantsList.appendChild(card);
                        });
                    }
                })
                .catch(error => {
                    console.error('Error al cargar participantes:', error);
                    participantsList.innerHTML = `<p>Error al cargar participantes: ${error.message}</p>`;
                });
        }
        
        function loadProjectChallenges(projectId) {
            const challengesList = document.getElementById('modal-challenges-list');
            const challengesCount = document.getElementById('modal-project-challenges');
            
            if (!challengesList) {
                console.warn('No se encontró la lista de desafíos');
                return;
            }
            
            fetch(`/api/proyectos/${projectId}/desafios`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Error ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(desafios => {
                    // Actualizar contador
                    if (challengesCount) {
                        challengesCount.textContent = desafios.length;
                    }
                    
                    // Mostrar desafíos
                    if (desafios.length === 0) {
                        challengesList.innerHTML = '<p>No hay desafíos en este proyecto.</p>';
                    } else {
                        challengesList.innerHTML = '';
                        desafios.forEach(desafio => {
                            const card = document.createElement('div');
                            card.className = 'challenge-list-item';
                            card.innerHTML = `
                                <div class="challenge-list-name">${desafio.nombre}</div>
                                <div class="challenge-list-desc">${desafio.descripcion || 'Sin descripción'}</div>
                                <div class="challenge-list-points">${desafio.puntosRecompensa || 0} puntos</div>
                            `;
                            challengesList.appendChild(card);
                        });
                    }
                })
                .catch(error => {
                    console.error('Error al cargar desafíos:', error);
                    challengesList.innerHTML = `<p>Error al cargar desafíos: ${error.message}</p>`;
                });
        }
        
        function updateProjectActions(proyecto) {
            // Verificar si existe el contenedor de acciones
            const actionsContainer = document.getElementById('modal-project-actions');
            if (!actionsContainer) {
                console.warn('No se encontró el elemento modal-project-actions');
                return; // Salir si no existe
            }
            
            let html = '';
            
            // Verificar si estoy participando en este proyecto
            const isParticipating = currentUserProjects.includes(proyecto.id);
            
            // LÓGICA ACTUALIZADA para los botones de acción en el modal
            if (isParticipating) {
                // Si participo, siempre puedo abandonar y ver el foro
                html += `
                    <button class="primary-action" onclick="gotoProjectForum('${proyecto.id}')">
                        <i class="fas fa-comments"></i> Ver Foro
                    </button>
                    <button class="secondary-action" onclick="leaveProject('${proyecto.id}')">
                        <i class="fas fa-sign-out-alt"></i> Abandonar
                    </button>
                `;
            } else if (proyecto.estado === 'ACTIVO' && !proyecto.haAlcanzadoLimiteParticipantes) {
                // Si no participo, el proyecto está activo y hay cupos
                html += `
                    <button class="primary-action" onclick="joinProject('${proyecto.id}')">
                        <i class="fas fa-hand-holding-heart"></i> Participar
                    </button>
                `;
            } else {
                // Para otros estados o si está completo y no participo
                const statusName = getStatusName(proyecto.estado);
                let messageText = statusName;
                
                if (proyecto.estado === 'ACTIVO' && (proyecto.haAlcanzadoLimiteParticipantes || proyecto.estado === 'COMPLETO')) {
                    messageText = 'Completo';
                }
                
                html += `
                    <button class="secondary-action" disabled>
                        <i class="fas fa-info-circle"></i> Proyecto ${messageText.toLowerCase()}
                    </button>
                `;
            }
            
            actionsContainer.innerHTML = html;
        }
        
        function getStatusName(estado) {
            switch (estado) {
                case 'ACTIVO': return 'Activo';
                case 'COMPLETADO': return 'Completado';
                case 'EXPIRADO': return 'Expirado';
                case 'CANCELADO': return 'Cancelado';
                default: return estado;
            }
        }
        
        function gotoProjectForum(projectId) {
            window.location.href = `/proyectos/${projectId}/foro`;
        }
        
        function toggleEditForm(show) {
            const form = document.getElementById('edit-project-form');
            if (form) {
                form.style.display = show ? 'block' : 'none';
            } else {
                console.error('Elemento edit-project-form no encontrado');
            }
        }
        
        function updateProject() {
            const projectId = document.getElementById('edit-project-id').value;
            
            // Crear objeto con los datos actualizados
            const updatedProject = {
                id: projectId,
                nombre: document.getElementById('edit-project-name').value,
                descripcion: document.getElementById('edit-project-description').value,
                estado: document.getElementById('edit-project-status').value
            };
            
            // Convertir fecha si existe
            const fechaExpiracion = document.getElementById('edit-project-expiration').value;
            if (fechaExpiracion) {
                updatedProject.fechaExpiracion = new Date(fechaExpiracion).toISOString();
            }
            
            // Enviar actualización
            fetch(`/api/proyectos/${projectId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(updatedProject)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Error ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(proyecto => {
                // Mostrar mensaje de éxito
                alert('Proyecto actualizado correctamente');
                
                // Ocultar formulario
                toggleEditForm(false);
                
                // Recargar detalles del proyecto
                openProjectDetails(projectId);
                
                // Recargar lista de proyectos
                loadDataAndRender();
            })
            .catch(error => {
                console.error('Error al actualizar proyecto:', error);
                alert(`Error al actualizar proyecto: ${error.message}`);
            });
        }
        
        function confirmDeleteProject() {
            const projectId = document.getElementById('edit-project-id').value;
            const projectName = document.getElementById('edit-project-name').value;
            
            if (confirm(`¿Estás seguro de que deseas eliminar el proyecto "${projectName}"? Esta acción no se puede deshacer.`)) {
                deleteProject(projectId);
            }
        }
        
        function deleteProject(projectId) {
            fetch(`/api/proyectos/${projectId}`, {
                method: 'DELETE'
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Error ${response.status}: ${response.statusText}`);
                }
                
                // Mostrar mensaje de éxito
                alert('Proyecto eliminado correctamente');
                
                // Cerrar modal
                closeModal('projectDetailModal');
                
                // Recargar lista de proyectos
                loadDataAndRender();
            })
            .catch(error => {
                console.error('Error al eliminar proyecto:', error);
                alert(`Error al eliminar proyecto: ${error.message}`);
            });
        }

        // Función para guardar proyectos en localStorage
        function saveUserProjectsToLocalStorage() {
            localStorage.setItem('userProjects', JSON.stringify(currentUserProjects));
            console.log('Proyectos guardados en localStorage:', currentUserProjects);
        }
        
        // Función para cargar proyectos desde localStorage
        function loadUserProjectsFromLocalStorage() {
            const storedProjects = localStorage.getItem('userProjects');
            if (storedProjects) {
                try {
                    currentUserProjects = JSON.parse(storedProjects);
                    console.log('Proyectos cargados desde localStorage:', currentUserProjects);
                    return true;
                } catch (e) {
                    console.error('Error al parsear proyectos del localStorage:', e);
                }
            }
            return false;
        }
        
        // Función para verificar participación directamente a través del servidor para un proyecto específico
        async function verificarParticipacionEnProyecto(projectId) {
            try {
                // Intento 1: Usar endpoint específico
                const checkResponse = await fetch(`${API_PROYECTOS_URL}/${projectId}/verificar-participacion`, {
                    method: 'GET'
                });
                
                if (checkResponse.ok) {
                    // Verificar que la respuesta sea JSON antes de intentar parsearla
                    const contentType = checkResponse.headers.get("content-type");
                    if (contentType && contentType.indexOf("application/json") !== -1) {
                        const result = await checkResponse.json();
                        return result.esParticipante === true;
                    }
                    // Si no es JSON, ignorar este intento y pasar al siguiente
                }
                
                // Intento 2: Verificar lista de participantes
                const participantsResponse = await fetch(`${API_PROYECTOS_URL}/${projectId}/participantes`);
                if (participantsResponse.ok) {
                    // Verificar que la respuesta sea JSON antes de intentar parsearla
                    const contentType = participantsResponse.headers.get("content-type");
                    if (contentType && contentType.indexOf("application/json") !== -1) {
                        const participants = await participantsResponse.json();
                        if (!window.userData || !window.userData.id) return false;
                        
                        return participants.some(p => 
                            p.id === window.userData.id || 
                            p.usuarioId === window.userData.id);
                    }
                    // Si no es JSON, ignorar este intento también
                }
            } catch (error) {
                console.warn(`Error al verificar participación para proyecto ${projectId}:`, error);
            }
            
            // Si todo falla, confiar en el valor almacenado localmente
            return currentUserProjects.includes(projectId);
        }
    </script>
    <script th:src="@{/js/menu.js}" defer></script>
</body>
</html>